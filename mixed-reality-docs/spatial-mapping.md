---
title: 空間マッピング
description: 空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供します。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間マッピング、HoloLens、mixed reality、surface 再構築、メッシュ
ms.openlocfilehash: c4e2f9e49cfe4df9cf875d18b19d62e25c200d76
ms.sourcegitcommit: 0a1af2224c9cbb34591b6cb01159b60b37dfff0c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79375829"
---
# <a name="spatial-mapping"></a>空間マッピング

空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供し、開発者が説得力のある mixed reality エクスペリエンスを作成できるようにします。 実際の世界を仮想環境にマージすることにより、アプリケーションは、ホログラムを現実に見せることができます。 また、アプリケーションは、実際の動作と相互作用を理解することで、ユーザーの期待に合わせて自然に配置できます。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>デバイスのサポート

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><strong>機能</strong></td>
        <td><a href="hololens-hardware-details.md"><strong>HoloLens (第 1 世代)</strong></a></td>
        <td><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></td>
        <td><a href="immersive-headset-hardware-details.md"><strong>イマーシブ ヘッドセット</strong></a></td>
    </tr>
     <tr>
        <td>空間マッピング</td>
        <td>✔️</td>
        <td>✔️</td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a>空間マッピングが重要な理由

空間マッピングにより、オブジェクトを実際のサーフェスの上に配置できるようになります。 これは、オブジェクトをユーザーの世界に固定し、実際の深さの手掛かりを活用するのに役立ちます。他のホログラムや実際のオブジェクトに基づいてホログラムを Occluding することで、これらのホログラムが実際に空間にあることをユーザーに納得させることができます。 領域内のホログラムまたはユーザーとの移動は実際とは言えません。 可能な場合は、アイテムを快適に配置します。

ホログラムを配置または移動するときにサーフェイスを視覚化します (単純な射影グリッドを使用します)。 これにより、ユーザーがホログラムを最適に配置できる場所を知ることができます。また、ホログラムを配置しようとしている場所がまだマップされていない場合は、ユーザーが表示されます。 角度が非常に多い場合は、ユーザーに "ビルボード項目" を設定できます。

## <a name="conceptual-overview"></a>概念の概要

部屋](images/SurfaceReconstruction.jpg) をカバーするメッシュサーフェスを ![します<br>
*部屋をカバーする空間マッピングメッシュの例*

空間マッピングに使用される2つの主なオブジェクトの種類は、"空間サーフェスオブザーバー" と "空間サーフェス" です。

アプリケーションは、1つまたは複数の境界ボリュームを持つ空間サーフェスオブザーバーを提供し、アプリケーションが空間マッピングデータを受け取る領域の領域を定義します。 これらの各ボリュームについて、空間マッピングによって、空間サーフェスのセットがアプリケーションに提供されます。

これらのボリュームは、(実際の世界に対して固定された場所で) 静止している場合や、HoloLens にアタッチされている場合があります (これらのボリュームは、環境内を移動するときに HoloLens と一緒に移動されますが、回転しません)。 各空間サーフェスは、ワールドロックされた[空間座標系](coordinate-systems.md)に関連付けられた三角形メッシュとして表される、小さい領域の実際のサーフェイスを表します。

HoloLens が環境に関する新しいデータを収集すると、環境に対する変更が発生すると、空間サーフェスが表示され、非表示になり、変更されます。

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a>空間マッピングとシーンについて WorldMesh を理解する
HoloLens 2 では、[シーンを理解する SDK](scene-understanding-SDK.md) (EnableWorldMesh 設定) を使用して、空間マッピングデータの静的なバージョンを照会することができます。 空間マッピングデータにアクセスする2つの方法の違いを次に示します。
* 空間マッピング API:
   * 制限された範囲: ユーザーに対してキャッシュされた ' バブル ' のサイズで、アプリケーションが使用できる空間マッピングデータ。
   * SurfacesChanged イベントによって変更されたメッシュ領域の低待機時間の更新を提供します。
   * 3次測定パラメーターあたりの三角形によって制御される詳細の可変レベル。
* シーンを理解する SDK:
   * 無制限の範囲-クエリ radius 内でスキャンされたすべての空間マッピングデータを提供します。
   * 空間マッピングデータの静的なスナップショットを提供します。 更新された空間マッピングデータを取得するには、メッシュ全体に対して新しいクエリを実行する必要があります。
   * RequestedMeshLevelOfDetail の設定によって制御される詳細レベルの一貫性。

## <a name="what-influences-spatial-mapping-quality"></a>空間マッピングの品質に影響を与えるもの

[ここ](environment-considerations-for-hololens.md)で説明するいくつかの要素は、これらのエラーの頻度と重大度に影響を与える可能性があります。  ただし、空間マッピングデータにエラーがある場合でも、ユーザーが目標を達成できるように、アプリケーションを設計する必要があります。

## <a name="common-usage-scenarios"></a>一般的な利用シナリオ

![一般的な空間マッピングの使用シナリオの図: 配置、閉鎖、物理、およびナビゲーション](images/sm-concepts-1000px.png)

### <a name="placement"></a>[位置]

空間マッピングを使用すると、アプリケーションは、自然で使い慣れた形でユーザーと対話することができます。電話をデスクに置いた方が、より自然なことがありますか。

サーフェイス上に配置されるホログラム (または、より一般的には、任意の空間位置の選択) の配置を制限すると、3D (空間のポイント) から 2D (サーフェス上の点) への自然なマッピングが実現します。 これにより、ユーザーがアプリケーションに提供する必要がある情報の量が削減されるため、ユーザーの操作をより迅速かつ簡単に、より正確に行うことができます。 これは特に、"距離が離れています" が、他の人間やコンピューターと物理的に通信するために使用されるものではないためです。 指をポイントすると、方向を指定しますが、距離は指定しません。

ここで重要な注意事項として、アプリケーションで方向からの距離が推測される場合 (たとえば、ユーザーの見つめ方向に沿って raycast を実行して最も近い空間サーフェスを検索する場合など)、ユーザーが確実に予測できる結果が得られる必要があります。 そうしないと、ユーザーは制御の意味を失い、すぐにフラストレーションを受ける可能性があります。 これに役立つ1つの方法は、1つだけではなく、複数の raycasts を実行することです。 集計結果は、より滑らかで予測可能であり、一時的な ' 外れ値 ' 結果からの影響を受けにくくなります (光線が小さな穴を通過するか、ユーザーが認識していないジオメトリの小さなビットに達したことによって発生する可能性があります)。 集計またはスムージングは、時間の経過と共に実行することもできます。たとえば、ホログラムがユーザーからの距離で変化する最大速度を制限できます。 最小距離と最大距離の値を制限するだけでも役に立ちます。したがって、移動するホログラムは、突然距離が離れたり、ユーザーの顔に戻ったりすることはありません。

アプリケーションでは、サーフェイスの形状と方向を使用して、ホログラムの配置をガイドすることもできます。 Holographic チェアは壁を通過しないようにする必要があります。また、やや不均一であっても、床との間にフラッシュする必要があります。 この種の機能は、単なる raycasts ではなく、物理的な衝突の使用に依存する可能性がありますが、同様の懸念が適用されます。 配置されているホログラムに、椅子の脚のような小さな多角形が多数含まれている場合は、それらの多角形の物理的な表現をより広い範囲で滑らかに拡張して、空間サーフェスを移動することができます。キャプチャ.

極端には、ユーザー入力を完全に簡略化し、空間サーフェスを使用して完全なホログラム配置を実行できます。 たとえば、アプリケーションでは、ユーザーが押すために壁のどこかに holographic ライトスイッチを配置できます。 予測可能性に関する注意事項は、ここでは二重に適用されます。ユーザーがホログラムの配置を制御する必要があるものの、アプリケーションが必要な場所にホログラムを配置することがない場合 (ライトスイッチがユーザーに届かない場所に表示される場合)、これは面倒なエクスペリエンスになります。 実際には、ユーザーが常に配置を実行する必要があるのではなく、ユーザーによる修正を必要とする自動配置を実行する方が悪くなることがあります。自動配置が正常に行われることが*予想*されるため、手動による修正は負担のように感じられます。

アプリケーションが空間サーフェスを配置に使用できるかどうかは、アプリケーションの[スキャンエクスペリエンス](spatial-mapping.md#the-environment-scanning-experience)に大きく左右されることにも注意してください。 サーフェイスがスキャンされていない場合は、配置に使用できません。 新しい画面をスキャンしたり、新しい場所を選択したりできるように、ユーザーに対してこのことを明確にする必要があります。

ユーザーへの視覚的なフィードバックは、配置時に非常に重要です。 ユーザーは、最も近い表面と、[接地効果](spatial-mapping.md#visualization)がある場所を認識している必要があります。 これらのユーザーは、ホログラムの動きが制約されている理由を理解している必要があります (たとえば、近くにある別のサーフェイスとの衝突が原因で)。 現在の場所にホログラムを配置できない場合、視覚的なフィードバックによって、その理由を明確にする必要があります。 たとえば、ユーザーが壁に holographic ソファを置いている場合、壁の背後にあるソファの部分は、怒った色で色を付ける必要があります。 反対に、ユーザーが実際の画面を見ることができる場所に空間サーフェイスが見つからない場合は、アプリケーションでこのことを明確にする必要があります。 この領域での接地効果が明らかでない場合は、この目的を達成することができます。

### <a name="occlusion"></a>オクルージョン

空間マッピングサーフェイスの主な用途の1つは、単にホログラムを occlude することです。 この単純な動作は、ホログラムのリアリティに大きな影響を与えるため、ユーザーと同じ物理空間をモックとする visceral sense を作成するのに役立ちます。

また、オクルージョンは、ユーザーに情報を提供します。occluded が本物の表面であると思われる場合、この方法では、世界中のホログラムの空間位置に関する追加の視覚的フィードバックが提供されます。 逆に、オクルージョンでは、ユーザーからの情報を*非表示*にすることもできます。壁の背後にある occluding ホログラムは、直感的な方法で視覚乱雑を軽減できます。 ホログラムを表示または非表示にするには、ユーザーは単にヘッドを移動する必要があります。

また、遮蔽を使用すると、使い慣れた物理的な対話に基づいて自然なユーザーインターフェイスの期待を達成することもできます。ホログラムがサーフェイスによって occluded されている場合、その表面はソリッドであるため、ユーザーは、ホログラムがその表面と*衝突*し、単に通過することを期待する必要があります。

場合によっては、ホログラムの遮蔽が望ましくないこともあります。 ユーザーがホログラムを操作できる必要がある場合は、実際の画面の背後にいる場合でも、ユーザーはそれを確認できる必要があります。 このような場合、通常は、occluded したときに (たとえば、明るさを下げることによって) このようなホログラムを別にレンダリングするのが理にかなっています。 こうすることで、ユーザーはホログラムを視覚的に見つけることができますが、それでもその背後にあることを認識できます。

### <a name="physics"></a>物理

物理シミュレーションを使用するもう1つの方法として、空間マッピングを使用して、ユーザーの物理空間にホログラムの*存在*を補強することができます。 私の holographic ゴムボールは、机の上から離れたときに、床でバウンスされ、ソファの下に見えなくなったときに、それが本当にないと信じられないかもしれません。

また、物理シミュレーションでは、アプリケーションで自然でわかりやすい物理操作を使用することもできます。 フロア上の holographic 家具を移動すると、家具が適切な慣性と摩擦によってフロア上でスライドしているかのように反応する場合、ユーザーにとってはもっと簡単になります。

現実的な物理的な動作を生成するために、穴の塗りつぶし、浮動 hallucinations の除去、ラフサーフェスのスムージングなど、[メッシュ処理](spatial-mapping.md#mesh-processing)の実行が必要になる可能性があります。

また、アプリケーションの[スキャンエクスペリエンス](spatial-mapping.md#the-environment-scanning-experience)が物理シミュレーションに与える影響についても考慮する必要があります。 最初は、不足しているサーフェスは何も競合しません。ゴムボールが corridor と、既知の世界の端から離れたときにどうなるでしょうか。 さらに、時間の経過と共に環境の変化に対応するかどうかを決定する必要があります。 場合によっては、可能な限り迅速に対応する必要があります。たとえば、ユーザーがドアと家具を、barricades の tempest に対する防御の可動として使用しているとします。 ただし、場合によっては、新しい更新プログラムを無視することもできます。犬がトラックの途中に座っていると判断した場合、holographic のスポーツ車をフロア上のレースの周りに置いても、突然楽しいことはありません。

### <a name="navigation"></a>ナビゲーション

アプリケーションでは、空間マッピングデータを使用して、実際の人と同じように、holographic 文字 (またはエージェント) が現実世界に移動できるようにすることができます。 これにより、ユーザーとその友人と同じ自然でなじみのある動作のセットに制限することで、holographic 文字が確実に存在するようになります。

ナビゲーション機能は、ユーザーにも役立ちます。 特定の領域にナビゲーションマップが構築されると、その場所を知らない新しいユーザーのために holographic の方向を提供するために共有することができます。 このマップは、歩行中のトラフィックの流れを円滑に保つため、または構築サイトなどの危険な場所での事故を防ぐために設計されている可能性があります。

ナビゲーション機能の実装に伴う技術的な課題の主な課題は、再生可能なサーフェイス (人間はテーブルをウォークしません) を確実に検出し、環境の変化に適切に適合させることです (人間は閉じたドアをたどることはできません)。 メッシュでは、仮想文字によるパスの計画とナビゲーションに使用できるようになる前に、何らかの[処理](spatial-mapping.md#mesh-processing)が必要になる場合があります。 メッシュをスムージングし、hallucinations を削除すると、文字が動かなくなるのを防ぐことができます。 また、文字のパス計画とナビゲーションの計算を高速化するために、メッシュを大幅に簡略化することもできます。 これらの課題は、videogame テクノロジの開発において非常に注意を払ってきました。これらのトピックには、豊富な研究資料があります。

Unity の組み込みのナビゲーションメッシュ機能は、空間マッピングサーフェイスでは使用できないことに注意してください。 これは、アプリケーションが開始されるまで空間マッピングサーフェイスが知られていないのに対して、ナビゲーションデータファイルは事前にソースアセットから生成する必要があるためです。 また、空間マッピングシステムは、ユーザーの現在の場所から離れた場所にある[サーフェイスに関する情報](spatial-mapping.md#the-environment-scanning-experience)を提供しないことにも注意してください。 そのため、非常に大きな領域のマップを作成する場合は、アプリケーションがそのサーフェイス自体を記憶する必要があります。

### <a name="visualization"></a>ビジュアル化

ほとんどの場合、空間サーフェスを非表示にするのが適切です。見た目が乱雑にならないようにして、現実世界の声を聞くことができます。 ただし、実際の対応するものが既に表示されているとしても、空間マッピングサーフェイスを直接視覚化すると便利な場合があります。

たとえば、ユーザーが表面にホログラムを配置しようとしたとき (壁に holographic キャビネットを配置する場合など)、表面に影をキャストすることによって、ホログラムを "接地" することが役に立つことがあります。 これにより、ホログラムと surface の物理的な距離を明確に理解できます。 これは、ユーザーがコミットする前に、変更を視覚的に "プレビュー" するより一般的な方法の例でもあります。

サーフェイスを視覚化することで、アプリケーションは環境についての理解をユーザーと共有できます。 たとえば、holographic board ゲームでは、"tables" として識別された水平サーフェスを視覚化することができます。これにより、ユーザーが対話する場所を知ることができます。

画面に表示されないユーザーの近くにあるスペースを表示するには、サーフェイスを視覚化すると便利です。 これにより、ユーザーがリビングルームからキッチン (およびそのすべてに含まれるホログラム) にアクセスできるようにするための簡単な方法が提供されます。

空間マッピングによって提供されるサーフェスメッシュは、特に "クリーン" ではない場合があります。 したがって、それらを適切に視覚化することが重要です。 従来の照明計算では、視覚的には見えない形で表面法線のエラーが強調表示される場合がありますが、画面上に投影された "クリーン" テクスチャは、外観を整えるのに役立ちます。 また、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行して、サーフェイスがレンダリングされる前にメッシュのプロパティを向上させることもできます。

> [!NOTE]
> HoloLens 2 では、新しいシーンである[ランタイム](scene-understanding.md)を実装しています。これは、配置、閉鎖、物理、およびナビゲーションの実装を簡略化するように設計された、構造化された高レベルの環境表現を使用して、Mixed Reality 開発者に提供します。

## <a name="using-the-surface-observer"></a>Surface オブザーバーの使用

空間マッピングの開始点は、surface オブザーバーです。 プログラムフローは次のとおりです。
* Surface オブザーバーオブジェクトを作成する
   * 1つまたは複数の空間ボリュームを指定して、アプリケーションが空間マッピングデータを受け取る対象領域を定義します。 空間ボリュームは、球体や箱などの領域の領域を定義する図形です。
   * ワールドロックの空間座標系で空間ボリュームを使用して、物理的な世界の固定領域を特定します。
   * 空間ボリュームを使用して、ボディロックされた空間座標系で各フレームを更新し、ユーザーとの間で移動する (ただし、回転しない) 領域を特定します。
   * これらの空間ボリュームは、アプリケーションまたはユーザーの状態が変化したときに、いつでも変更できます。
* ポーリングまたは通知を使用して空間サーフェスに関する情報を取得する
   * 空間サーフェスの状態については、いつでも surface オブザーバーを "ポーリング" できます。 また、surface オブザーバーの ' surface changed ' イベントに登録することもできます。これにより、空間サーフェスが変化したときにアプリケーションに通知されます。
   * ビューが錐である、または本文でロックされているボリュームのような動的な空間ボリュームの場合、アプリケーションは、必要な領域を設定し、現在の空間サーフェスのセットを取得することによって、各フレームの変更に対してポーリングを行う必要があります。
   * 1つのルームをカバーするワールドロックキューブなどの静的ボリュームの場合、アプリケーションは、そのボリューム内の空間サーフェスが変更された場合に通知されるように "サーフェイス changed" イベントに登録できます。
* サーフェイスの変化を処理する
   * 指定された空間サーフェイスのセットを反復処理します。
   * 空間サーフェスを追加、変更、または削除済みとして分類します。
   * 追加または変更された空間サーフェイスごとに、必要に応じて、必要な詳細レベルでサーフェイスの現在の状態を表す更新されたメッシュを受け取る非同期要求を送信します。
* 非同期メッシュ要求を処理します (以降のセクションで詳しく説明します)。

## <a name="mesh-caching"></a>メッシュキャッシュ

空間サーフェスは、高密度三角形メッシュによって表されます。 これらのメッシュを格納、表示、および処理すると、コンピューティングリソースとストレージリソースが大幅に消費される可能性があります。 そのため、各アプリケーションは、メッシュの処理とストレージに使用されるリソースを最小限に抑えるために、ニーズに適したメッシュキャッシュ方式を採用する必要があります。 このスキームでは、どのメッシュを保持するか、破棄するか、および各空間サーフェイスのメッシュをいつ更新するかを決定する必要があります。

ここで説明する考慮事項の多くは、アプリケーションがメッシュキャッシュにどのように対処する必要があるかを直接通知します。 ユーザーが環境内をどのように移動するか、どのサーフェイスが必要であるか、および環境内の変更をいつキャプチャするかを考慮する必要があります。

Surface オブザーバーによって提供される "変化したサーフェイス" イベントを解釈する場合、基本的なメッシュキャッシュのロジックは次のようになります。
* 前に見られていない空間サーフェス ID がアプリケーションに表示される場合、これを新しい空間サーフェスとして扱います。
* アプリケーションが既知の ID を持つ空間サーフェスを認識し、新しい更新時間がある場合は、これを更新された空間サーフェスとして扱う必要があります。
* 既知の ID を持つ空間サーフェスがアプリケーションに表示されなくなった場合は、これを削除された空間サーフェスとして扱います。

次に、各アプリケーションに対して次の選択を行います。
* 新しい空間サーフェスの場合、メッシュを要求する必要がありますか。
   * 通常メッシュは、新しい空間サーフェスに対してすぐに要求する必要があります。これにより、ユーザーに有用な新しい情報が提供される可能性があります。
   * ただし、ユーザーの前と前にある新しい空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。
   * 新しいメッシュが必要ない場合、たとえば、アプリケーションが環境のモデルを永続的または一時的に "フリーズ" している場合は、そのモデルを要求しないようにする必要があります。
* 更新された空間サーフェスの場合、メッシュを要求する必要がありますか。
   * ユーザーの前と手前にある更新された空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。
   * また、特にスキャンエクスペリエンス中に、更新されたサーフェイスよりも新しいサーフェイスに優先順位を付けることが適切な場合もあります。
   * 処理コストを制限するために、アプリケーションでは、空間サーフェスへの更新を処理する速度を調整することが必要になる場合があります。
   * たとえば、サーフェイスの境界が小さい場合など、空間サーフェスに対する変更は軽微であると推測できます。この場合、更新は処理するのに十分ではない可能性があります。
   * 現在のユーザーの関心領域外の空間サーフェスに対する更新は完全に無視される場合がありますが、この場合は、surface オブザーバーによって使用されている空間境界ボリュームを変更する方が効率的な場合があります。
* 削除された空間サーフェスの場合、メッシュを破棄する必要がありますか。
   * 通常メッシュは、削除された空間サーフェスに対して直ちに破棄され、ホログラムの閉鎖が適切な状態のままになります。
   * ただし、アプリケーションが (ユーザーエクスペリエンスの設計に基づいて) 後すぐに空間サーフェスを再表示するという理由がある場合は、メッシュを破棄して後で再作成するよりも、それを保持する方が効率的な場合があります。
   * アプリケーションがユーザーの環境の大規模なモデルを構築している場合、メッシュを破棄したくない場合があります。 ただし、空間サーフェスが表示されなくなったときにメッシュをディスクにスプールすることによって、リソースの使用量を制限する必要があります。
   * 空間サーフェスの生成中に比較的まれなイベントが発生すると、空間サーフェスが、同じ場所の新しい空間サーフェスに置き換えられることがありますが、Id が異なることに注意してください。 そのため、削除されたサーフェイスを破棄しないことを選択したアプリケーションは、同じ場所をカバーする複数の高重複空間サーフェスメッシュによって終了しないように注意する必要があります。
* 他の空間サーフェイスではメッシュを破棄する必要がありますか。
   * 空間サーフェイスが存在していても、ユーザーのエクスペリエンスには不要になった場合は、破棄する必要があります。 たとえば、アプリケーションが入室のもう一方の側の部屋を代替仮想空間と置き換える場合、そのルームの空間サーフェスは不要になります。

次に、空間とテンポラルヒステリシスを使用したメッシュキャッシュ方法の例を示します。
* アプリケーションでは、ユーザーの宝石に沿って視される、視錐のある空間ボリュームを使用することを検討してください。
* 空間サーフェスがこのボリュームから一時的に消える可能性があるのは、ユーザーがその画面から離れた場所から離れているためです。後でもう一度参照するか、さらに近い位置に移動します。 この場合、このサーフェイスのメッシュを破棄して再作成すると、大量の冗長処理が発生します。
* 処理される変更の数を減らすために、アプリケーションは2つの空間サーフェスオブザーバーを使用します。1つは他方に含まれています。 大きいボリュームは球面で、ユーザーの ' 遅延 ' に従います。必要な場合にのみ移動し、そのセンターがユーザーの 2.0 metres 内にあることを確認します。
* 新規および更新された空間サーフェスメッシュは、常に小さい内部サーフェスオブザーバーから処理されますが、メッシュは大きな外部サーフェスオブザーバーから見えなくなるまでキャッシュされます。 これにより、アプリケーションは、ローカルユーザーの移動によって多くの冗長な変更を処理することを回避できます。
* 空間サーフェスは、追跡が失われることによって一時的に消去される場合もあるため、アプリケーションは、追跡の損失中に削除された空間サーフェスの破棄を延期します。
* 一般に、アプリケーションでは、更新処理の減少とメモリ使用量の増加のトレードオフを評価して、最適なキャッシュ戦略を決定する必要があります。

## <a name="rendering"></a>レンダリング

空間マッピングメッシュがレンダリングに使用される傾向がある主な方法には、次の3つがあります。
* Surface の視覚化の場合
   * 多くの場合、空間サーフェスを直接視覚化すると便利です。 たとえば、オブジェクトから空間サーフェスに ' shadows ' をキャストすると、サーフェイスにホログラムを配置するときに、視覚的なフィードバックをユーザーに提供できます。
   * 空間メッシュは、3D アーティストによって作成されるメッシュの種類とは異なる点に注意してください。 トライアングルトポロジは人間が作成したトポロジとして "クリーン" ではなく、メッシュが[さまざまなエラー](spatial-mapping.md#what-influences-spatial-mapping-quality)によって影響を受けます。
   * 見栄えの良いビジュアルを作成するには、穴や smooth surface の法線を塗りつぶすなど、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行することが必要になる場合があります。 また、メッシュトポロジや法線を直接視覚化するのではなく、シェーダーを使用して、アーティストによって設計されたテクスチャをメッシュに射影することもできます。
* 実際のサーフェイスの背後にある occluding ホログラムの場合
   * 空間サーフェスは、[深度バッファー](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)にのみ影響を与え、カラーレンダーターゲットには影響しない、深度のみのパスでレンダリングできます。
   * これにより、空間サーフェスの背後でレンダリングされるホログラムを occlude するための深度バッファーが primes されます。 ホログラムを正確に遮蔽することで、ユーザーの物理的な領域内にホログラムが本当に存在するという意味が高まります。
   * 深度のみのレンダリングを有効にするには、blend の状態を更新して、すべてのカラーレンダーターゲットで[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)を0に設定します。
* 実際のサーフェイスによるホログラム occluded の外観を変更するには
   * 通常表示されるジオメトリは、occluded すると非表示になります。 これを実現するには、深度ステンシルの[状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)の depth 関数を "次の値以下" に設定します。これにより、以前にレンダリングされたすべてのジオメトリよりもカメラに**近い**場所にのみジオメトリが表示されるようになります。
   * ただし、特定のジオメトリが occluded されていても表示されないようにしたり、視覚的なフィードバックをユーザーに提供する手段として occluded したときの外観を変更したりすると便利な場合があります。 たとえば、これにより、アプリケーションは、実際の画面の背後にあることを明確にしながら、オブジェクトの場所をユーザーに表示できます。
   * これを実現するには、必要な ' occluded ' 外観を作成する別のシェーダーを使用して、ジオメトリをもう一度描画します。 2回目のジオメトリをレンダリングする前に、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)に2つの変更を加えます。 最初に、深度関数を "以上" に設定します。これにより、ジオメトリは、**以前にレンダリングされ**たすべてのジオメトリよりもカメラから見た場合にのみ表示されるようになります。 次に、DepthWriteMask を0に設定して、深度バッファーが変更されないようにします (深度バッファーは、カメラに**最も近い**ジオメトリの深さを継続して表す必要があります)。

空間マッピングメッシュをレンダリングする場合、[パフォーマンス](understanding-performance-for-mixed-reality.md)は重要な問題です。 空間マッピングメッシュのレンダリングに固有のレンダリングパフォーマンス手法を次に示します。
* 三角形の密度を調整する
   * Surface オブザーバーから空間サーフェスメッシュを要求するときは、必要に応じて十分な三角形メッシュの最低密度を要求します。
   * 画面上の三角形の密度は、ユーザーからの距離とユーザーエクスペリエンスに対する関係に応じて、サーフェス単位で変化させることができます。
   * トライアングル数を減らすと、GPU のメモリ使用量と頂点処理コストが削減されますが、ピクセル処理のコストには影響しません。
* 錐のあるカリングを実行する
   * 視錐台のカリングは、表示できない描画オブジェクトをスキップします。これは、現在のディスプレイが視錐であるためです。 これにより、CPU と GPU の両方の処理コストが削減されます。
   * カリングはメッシュごとに実行されるため、空間サーフェスは大きくなる可能性があるため、各空間サーフェスメッシュを小さなチャンクに分割すると、より効率的なカリングを実現できます (オフスクリーンの三角形がレンダリングされます)。 ただし、トレードオフがあります。メッシュ数が多いほど描画呼び出しが多くなるため、CPU コストが増加する可能性があります。 極端なケースでは、錐のあるカリングの計算自体が、測定可能な CPU コストを持つことさえあります。
* レンダリング順序の調整
   * 空間サーフェスは、周囲のユーザーの環境全体を表しているため、サイズが大きくなる傾向があります。 これにより、GPU のピクセル処理コストが高くなる可能性があります。これは特に、可視ジオメトリのレイヤーが複数存在する場合 (空間サーフェスとその他のホログラムを含む) の場合に特に当てはまります。 この場合、ユーザーに最も近いレイヤーはさらにレイヤーを occluding するため、遠くのレイヤーをレンダリングするのに費やされた GPU 時間は無駄になります。
   * GPU 上のこの冗長な作業を減らすために、不透明なサーフェスを前方から後方にレンダリングするのに役立ちます (先に近い順にします)。 ' 不透明 ' では、DepthWriteMask が[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)で1に設定されているサーフェイスを意味します。 最も近いサーフェイスがレンダリングされると、GPU のピクセルプロセッサによって遠く離れたサーフェイスが効率的にスキップされるように、深度バッファーが最適になります。

## <a name="mesh-processing"></a>メッシュ処理

アプリケーションでは、必要に応じて、空間サーフェスメッシュに対して[さまざまな操作](spatial-mapping.md#mesh-processing)を実行することができます。 各空間サーフェスメッシュで提供されるインデックスおよび頂点データは、すべての最新のレンダリング Api で三角形メッシュをレンダリングするために使用される[頂点およびインデックスバッファー](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)と同じ使い慣れたレイアウトを使用します。 ただし、重要な1つの重要な点は、空間マッピングの三角形には、**反時計回りの回転順序**があるということです。 各三角形はメッシュのインデックスバッファー内の3つの頂点インデックスによって表されます。これらのインデックスは、三角形が**正面**から表示されるときに、三角形の頂点を**時計回り**の順序で識別します。 空間サーフェスメッシュの前面 (または外側) は、実際のサーフェイスの前面 (表示されている側) に期待されるように対応します。

アプリケーションでは、surface オブザーバーによって提供される coarsest 三角形の密度がまだ粗いことがない場合にのみメッシュの単純化を実行する必要があります。この作業は負荷が高く、ランタイムがさまざまなを生成するために既に実行されています。提供される詳細レベル。

各サーフェイスオブザーバーは複数の未接続空間サーフェスを提供できるため、アプリケーションによっては、これらの空間サーフェスメッシュを相互にクリップし、それらをまとめて zipper ことが必要になる場合があります。 一般的に、隣接する空間サーフェスメッシュが少し重なっているため、クリッピング手順が必要です。

## <a name="raycasting-and-collision"></a>Raycasting と競合

アプリケーションで空間サーフェスの raycasting および衝突機能を使用できるようにするために、物理 API (の場合は、等[ok](https://www.havok.com/)) では、アプリケーションで物理 api に空間サーフェスメッシュを提供する必要があります。 物理に使用されるメッシュには、次の特性があります。
* これらには、少数の三角形しか含まれていません。 物理操作は、レンダリング操作よりも計算が多くなります。
* このような場合は、"水がきつい" になります。 ソリッドであることを意図したサーフェスは、小さな穴を持つことはできません。表示できない穴が小さすぎる場合でも、問題が発生する可能性があります。
* これらは、凸状 hulls に変換されます。 凸状の hulls にはいくつかのポリゴンがあり、穴は不要であり、生の三角形メッシュよりも処理がはるかに効率的です。

空間サーフェスに対して raycasts を実行するときは、机のように、これらのサーフェスが複雑で、乱雑なものではないことに注意してください。 つまり、1つの raycast では、画面の形状や、その近くにある空の領域の形状に関する十分な情報を得ることができません。 そのため、通常は小さな領域内で多くの raycasts を実行し、集計結果を使用して、より信頼性の高いサーフェイスの理解を得ることをお勧めします。 たとえば、平均 10 raycasts を使用して、表面にホログラムの配置を行うと、1つの raycast だけを使用して、はるかに滑らかで "ちらつき" の結果が得られます。

ただし、raycast ごとに計算コストが高くなる可能性があることに注意してください。 したがって、使用シナリオによっては、(すべてのフレームで実行される) 追加の raycasts の計算コストと[メッシュ処理](spatial-mapping.md#mesh-processing)の計算コストを比較して、空間サーフェスの穴を滑らかにしたり削除したりする必要があります (空間メッシュを更新したときに実行されます)。

## <a name="the-environment-scanning-experience"></a>環境のスキャンエクスペリエンス

空間マッピングを使用する各アプリケーションでは、"スキャンエクスペリエンス" を提供することを検討する必要があります。アプリケーションが正常に機能するために必要なサーフェイスをスキャンするためにアプリケーションがユーザーに指示するプロセス。

スキャン](images/sr-mixedworld-140429-8pm-00068-1000px.png) の ![例<br>
*スキャンの例*

このスキャンエクスペリエンスの性質は、アプリケーションのニーズによって大きく異なる場合がありますが、主に2つの原則として設計を行う必要があります。

まず、**ユーザーとの通信をクリア**します。 ユーザーは、アプリケーションの要件が満たされているかどうかを常に把握している必要があります。 これらが満たされていない場合は、その理由をユーザーにすぐに明確にする必要があります。また、適切な操作を行うための迅速な対応が必要になります。

また、**アプリケーションは、効率性と信頼性のバランスを取るように試み**ます。 **信頼性**を高めるために、アプリケーションでは、ユーザー時間を節約するために、空間マッピングデータを自動的に分析する必要があります。 信頼性を高めることができない場合は、アプリケーションでは、アプリケーションに必要な追加情報を迅速に提供できるようにする必要があります。

適切なスキャンエクスペリエンスを設計するために、アプリケーションに適用できる次のような可能性を検討してください。

* **スキャンエクスペリエンスがありません**
   * アプリケーションは、ガイド付きスキャンを使用しなくても完璧に機能します。自然なユーザー移動の過程で観察されたサーフェイスについて説明します。
   * たとえば、ユーザーが holographic スプレーペイントを使用してサーフェイス上に描画できるようにするアプリケーションでは、ユーザーに現在表示されているサーフェイスの知識のみが必要です。
   * ユーザーが HoloLens を使用して既に多数の時間を費やしている場合、環境は既に完全にスキャンされている可能性があります。
   * ただし、空間マッピングによって使用されるカメラでは、ユーザーの前に 3.1 m しか表示されないことに注意してください。そのため、ユーザーが過去の距離を超えていない限り、空間マッピングは遠く離れたサーフェイスを認識しません。
   * スキャンされたサーフェイスをユーザーが理解できるように、アプリケーションはこの効果に対して視覚的なフィードバックを提供する必要があります。たとえば、仮想シャドウをスキャンしたサーフェイスにキャストすると、ユーザーがこれらのサーフェイスにホログラムを配置するのに役立ちます。
   * この場合、空間サーフェスオブザーバーの境界ボリュームは、各フレームを本文ロックされた[空間座標系](coordinate-systems.md)に更新して、ユーザーがフォローするようにする必要があります。

* **適切な場所の検索**
   * アプリケーションは、特定の要件を持つ場所で使用するように設計されている場合があります。
   * たとえば、アプリケーションでは、holographic kung-fu を安全に実行できるように、ユーザーの周囲に空の領域が必要になる場合があります。
   * アプリケーションでは、特定の要件をユーザーに事前に伝え、視覚的なフィードバックを明確にする必要があります。
   * この例では、アプリケーションは必要な空の領域の範囲を視覚化し、このゾーン内の不要なオブジェクトの存在を視覚的に強調表示する必要があります。
   * この場合、空間サーフェスのオブザーバーの境界ボリュームは、選択した場所でワールドロックの[空間座標系](coordinate-systems.md)を使用する必要があります。

* **サーフェイスの適切な構成を見つける**
   * アプリケーションでは、たとえば、2つの大規模なフラットな壁面の壁を作るために、特定のサーフェイスの構成が必要になる場合があります。
   * このような場合、アプリケーションでは、空間マッピングによって提供されるサーフェスを分析して適切なサーフェイスを検出し、ユーザーに対してユーザーに指示する必要があります。
   * アプリケーションのサーフェイス分析が完全に信頼できない場合は、フォールバックオプションが必要です。 たとえば、アプリケーションで入室がフラットな壁として誤って識別される場合、このエラーを修正するための簡単な方法が必要になります。

* **環境の一部をスキャンする**
   * アプリケーションでは、ユーザーの指示に従って、環境の一部のみをキャプチャすることをお勧めします。
   * たとえば、アプリケーションは部屋の一部をスキャンするので、ユーザーが販売する家具用に分類された holographic 広告を投稿することができます。
   * この場合、アプリケーションは、スキャン中にユーザーによって監視されているリージョン内の空間マッピングデータをキャプチャする必要があります。

* **部屋全体をスキャンする**
   * アプリケーションでは、ユーザーの背後にあるものも含め、現在の部屋にあるすべてのサーフェイスのスキャンが必要になる場合があります。
   * たとえば、ゲームでは、すべての方向から何百もの Lilliputians が発生した場合に、ユーザーを Gulliver のロールに配置することができます。
   * このような場合、アプリケーションは、現在の部屋に既にスキャンされているサーフェイスの数を判断し、大きなギャップを埋めるようにユーザーの宝石を誘導する必要があります。
   * このプロセスの重要なのは、まだスキャンされていないサーフェイスをユーザーに明確にするための視覚的なフィードバックを提供することです。 アプリケーションでは、[距離ベースのフォグ](https://msdn.microsoft.com/library/windows/desktop/bb173401%28v=vs.85%29.aspx)を使用して、空間マッピングサーフェイスでカバーされていない領域を視覚的に強調することができます。

* **環境の初期スナップショットを取得する**
   * アプリケーションでは、初期の "スナップショット" を取得した後、環境内のすべての変更を無視することができます。
   * これは、ユーザーが作成した、環境の初期状態と密接に結び付いているデータの中断を回避するために適している場合があります。
   * この場合、アプリケーションは、スキャンが完了したら、初期状態で空間マッピングデータのコピーを作成する必要があります。
   * 環境によってホログラムが正しく occluded されていない場合、アプリケーションは空間マッピングデータへの更新の受信を続行する必要があります。
   * 空間マッピングデータを継続的に更新することで、発生したすべての変更を視覚化することができ、環境の以前の状態と現在の状態の違いをユーザーに明確にすることができます。

* **環境のユーザーが開始したスナップショットを取得する**
   * アプリケーションでは、ユーザーによって指示された場合にのみ、環境の変更に応答する必要があります。
   * たとえば、ユーザーは、さまざまな瞬間にその場所をキャプチャすることにより、友人の複数の 3D ' statues ' を作成できます。

* **ユーザーが環境を変更できるようにする**
   * アプリケーションは、ユーザーの環境で行われた変更にリアルタイムで応答するように設計されている場合があります。
   * たとえば、curtain を描画したユーザーは、holographic play に対して "シーンの変更" をトリガーできます。

* **空間マッピングデータのエラーを回避するためのユーザーガイド**
   * アプリケーションでは、環境のスキャン中にユーザーにガイダンスを提供することができます。
   * これにより、ユーザーは、sunlit のウィンドウやミラーを離れるなどして、[空間マッピングデータ内](spatial-mapping.md#what-influences-spatial-mapping-quality)の特定の種類のエラーを回避できます。

注意すべきもう1つの詳細は、空間マッピングデータの "範囲" が無制限ではないことです。 空間マッピングでは、大きなスペースの永続的なデータベースが構築されますが、ユーザーの周囲のサイズが制限された ' バブル ' では、アプリケーションでそのデータを使用できるようになります。 したがって、長い corridor の先頭から開始して、開始から十分な距離が得られない場合は、最終的に空間サーフェスが先頭に戻ることになります。 もちろん、これらのサーフェイスは、使用可能な空間マッピングデータから消滅した後で、アプリケーションにキャッシュすることで軽減できます。

## <a name="mesh-processing"></a>メッシュ処理

これは、サーフェイス内の一般的なエラーの種類を検出し、必要に応じて空間マッピングデータをフィルター処理、削除、または変更するのに役立ちます。

空間マッピングデータは、実際のサーフェイスにできるだけ忠実として使用することを想定しているので、どのような処理を適用しても、画面が "真実" からさらに変化することに注意してください。

役に立つ可能性があるさまざまな種類のメッシュ処理の例を次に示します。

* **穴の塗りつぶし**
   * ダークマテリアルで作成された小さなオブジェクトがスキャンに失敗した場合、周囲のサーフェイスに穴が残されます。
   * 穴はオクルージョンに影響します。ホログラムは、不透明な現実世界の表面に穴を表示できます。
   * 穴は raycasts に影響します。ユーザーがサーフェイスを操作するために raycasts を使用している場合、これらの光線が穴を通過することは望ましくありません。 軽減策の1つは、適切にサイズ設定されたリージョンをカバーする複数の raycasts のバンドルを使用することです。 これにより、"外れ値" の結果をフィルター処理して、1つの raycast が小さな穴を通過した場合でも、集計結果が引き続き有効になるようにすることができます。 ただし、このアプローチには計算コストがかかることに注意してください。
   * 穴は物理的な衝突に影響します。物理シミュレーションによって制御されるオブジェクトは、床の穴を通過して失われる可能性があります。
   * Surface メッシュでは、このような穴をアルゴリズムに塗りつぶすことができます。 ただし、windows や doorways などの "実際のホール" が入力されないように、アルゴリズムを調整する必要があります。 ' 実際のホール ' を ' 虚数穴 ' から確実に区別することは困難であるため、' size ' や ' 境界図形 ' などのさまざまなヒューリスティックを試してみる必要があります。

* **Hallucination の削除**
   * 反射、明るいライト、およびオブジェクトの移動は、中程度の小さな残留物を維持することができます。
   * Hallucinations への影響の影響: Hallucinations は、他のホログラムの前に移動するダークシェイプとして表示されることがあります。
   * Hallucinations は raycasts に影響します。 raycasts を使用してユーザーがサーフェイスを操作できるようにする場合、これらの光線は、背後にある表面ではなく hallucination にヒットする可能性があります。 穴の場合と同様に、1つの raycast ではなく多くの raycasts を使用することができますが、この場合も計算コストが発生します。
   * Hallucinations は、物理的な衝突に影響を与えます。物理シミュレーションによって制御されるオブジェクトは、hallucination に対してスタックし、一見した領域の領域を移動できなくなる可能性があります。
   * Surface メッシュからこのような hallucinations をフィルター処理できます。 ただし、穴の場合と同様に、照明とドアハンドルなどの実際の小さなオブジェクトが削除されないように、アルゴリズムを調整する必要があります。

* **滑らかさ**
   * 空間マッピングは、実際の対応するものと比較して、粗いまたは "雑音" のように見える表面を返すことがあります。
   * 滑らかさは、物理的な衝突に影響します。フロアが粗い場合は、物理的にシミュレートされたゴルフボールが直線内でスムーズにロールすることはできません。
   * 滑らかさはレンダリングに影響します。表面が直接視覚化されている場合、表面法線の外観が影響を受けることがあり、' クリーン ' の外観が中断される可能性があります。 サーフェイスのレンダリングに使用されるシェーダー内の適切な光源とテクスチャを使用することによって、これを軽減することができます。
   * Surface メッシュでの粗さを滑らかにすることができます。 ただし、これにより、対応する実際のサーフェイスから離れた場所にサーフェイスがプッシュされる可能性があります。 近接性を維持することは、正確なホログラムオクルージョンを生成し、ユーザーが holographic サーフェイスとの正確で予測可能な相互作用を実現できるようにするために重要です。
   * コスメティックの変更のみが必要な場合は、頂点の位置を変更せずに頂点の法線を滑らかにするだけで十分な場合があります。

* **平面の検索**
   * アプリケーションでは、空間マッピングによって提供されるサーフェイスに対して実行する必要のあるさまざまな形式の分析があります。
   * 単純な例の1つは、"平面検索" です。サーフェイスの境界領域、主に平面領域を識別します。
   * 平面領域は、アプリケーションによって holographic コンテンツが自動的に配置される holographic のワークサーフェスとして使用できます。
   * 平面領域では、ユーザーインターフェイスを制限して、ユーザーがニーズに最も合ったサーフェイスと対話できるようにします。
   * 平面領域は、LCD 画面、テーブル、ホワイトボードなどの機能オブジェクトに対応する holographic のために、実際の世界のように使用できます。
   * 平面領域では、再生領域を定義して、videogame レベルの基礎を形成できます。
   * 平面領域を使用すると、仮想エージェントは、実際の人間が見ている可能性のあるフロアの領域を特定することで、実際の世界を移動できます。

## <a name="prototyping-and-debugging"></a>プロトタイプとデバッグ

### <a name="useful-tools"></a>便利なツール
* [Hololens エミュレーター](using-the-hololens-emulator.md)は、物理的な hololens にアクセスせずに空間マッピングを使用するアプリケーションを開発するために使用できます。 これにより、hololens でのライブセッションをリアルな環境でシミュレートし、アプリケーションが通常使用するすべてのデータ (HoloLens モーション、空間座標系、空間マッピングメッシュなど) を使用することができます。 これを使用すると、信頼性のある反復可能な入力を提供できます。これは、問題をデバッグし、コードの変更を評価するのに役立ちます。
* シナリオを再現するには、ライブ HoloLens からネットワーク経由で空間マッピングデータをキャプチャし、それをディスクに保存して、後続のデバッグセッションで再利用します。
* [Windows デバイスポータルの3d ビュー](using-the-windows-device-portal.md#3d-view)では、空間マッピングシステムを介して現在使用可能なすべての空間サーフェスを確認することができます。 これにより、アプリケーション内の空間サーフェスを比較する基準が提供されます。たとえば、不足しているか、間違った場所に表示されている空間サーフェスがあるかどうかを簡単に確認できます。

### <a name="general-prototyping-guidance"></a>プロトタイプの一般的なガイダンス
* 空間マッピングデータの[エラー](spatial-mapping.md#what-influences-spatial-mapping-quality)はユーザーのエクスペリエンスに大きな影響を与える可能性があるため、さまざまな環境でアプリケーションをテストすることをお勧めします。
* たとえば、机で同じ場所に常にテストするという習慣ではトラップされません。 さまざまな位置、形状、サイズ、およびマテリアルのさまざまなサーフェイスでテストを行うようにしてください。
* 同様に、統合または記録されたデータはデバッグに役立ちますが、同じ少数のテストケースには依存しないようにしてください。 これにより、より多様なテストが以前に検出された重要な問題を見つけることが遅れる可能性があります。
* 実際のユーザー (および理想的には coached ではありません) でテストを実行することをお勧めします。これは、ユーザーが HoloLens またはアプリケーションをまったく同じ方法で使用しない可能性があるためです。 実際には、異なるているユーザーの行動、知識、および前提条件はどのようになるかを驚かれるかもしれません。

## <a name="troubleshooting"></a>トラブルシューティング
* サーフェスメッシュを適切に配置するためには、各 SurfaceObserver オブジェクトをアクティブにしてから、メッシュが構築されるようにする必要があります。 そうしないと、メッシュはスペースに表示されますが、回転角度は変わってきます。
* SurfaceObserver と通信するスクリプトを実行するオブジェクトは、オリジンに設定する必要があります。 そうしないと、メッシュを構築するために作成して SurfaceObserver に送信するすべてのゲームオブジェクトが、親 Game オブジェクトのオフセットと同じオフセットを持つことになります。 これにより、メッシュがいくつかのメーターを表示して、何が起こっているかを簡単にデバッグできるようになります。

## <a name="see-also"></a>参照
* [座標系](coordinate-systems.md)
* [DirectX の空間マッピング](spatial-mapping-in-directx.md)
* [Unity の空間マッピング](spatial-mapping-in-unity.md)
* [シーンの理解](scene-understanding.md)
* [部屋のスキャンの可視化](room-scan-visualization.md)
* [立体音響の設計](spatial-sound-design.md)
* [ケース スタディ - Mixed Reality で穴から覗く](case-study-looking-through-holes-in-your-reality.md)
