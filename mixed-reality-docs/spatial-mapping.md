---
title: 空間マッピング
description: 空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供します。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間マッピング、HoloLens、mixed reality、surface 再構築、メッシュ
ms.openlocfilehash: c4e2f9e49cfe4df9cf875d18b19d62e25c200d76
ms.sourcegitcommit: 0a1af2224c9cbb34591b6cb01159b60b37dfff0c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79375829"
---
# <a name="spatial-mapping"></a><span data-ttu-id="4ec02-104">空間マッピング</span><span class="sxs-lookup"><span data-stu-id="4ec02-104">Spatial mapping</span></span>

<span data-ttu-id="4ec02-105">空間マッピングは、HoloLens の周囲の環境における実際のサーフェイスの詳細な表現を提供し、開発者が説得力のある mixed reality エクスペリエンスを作成できるようにします。</span><span class="sxs-lookup"><span data-stu-id="4ec02-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="4ec02-106">実際の世界を仮想環境にマージすることにより、アプリケーションは、ホログラムを現実に見せることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="4ec02-107">また、アプリケーションは、実際の動作と相互作用を理解することで、ユーザーの期待に合わせて自然に配置できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="4ec02-108">デバイスのサポート</span><span class="sxs-lookup"><span data-stu-id="4ec02-108">Device support</span></span>

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><span data-ttu-id="4ec02-109"><strong>機能</strong></span><span class="sxs-lookup"><span data-stu-id="4ec02-109"><strong>Feature</strong></span></span></td>
        <td><span data-ttu-id="4ec02-110"><a href="hololens-hardware-details.md"><strong>HoloLens (第 1 世代)</strong></a></span><span class="sxs-lookup"><span data-stu-id="4ec02-110"><a href="hololens-hardware-details.md"><strong>HoloLens (1st gen)</strong></a></span></span></td>
        <td><span data-ttu-id="4ec02-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span><span class="sxs-lookup"><span data-stu-id="4ec02-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span></span></td>
        <td><span data-ttu-id="4ec02-112"><a href="immersive-headset-hardware-details.md"><strong>イマーシブ ヘッドセット</strong></a></span><span class="sxs-lookup"><span data-stu-id="4ec02-112"><a href="immersive-headset-hardware-details.md"><strong>Immersive headsets</strong></a></span></span></td>
    </tr>
     <tr>
        <td><span data-ttu-id="4ec02-113">空間マッピング</span><span class="sxs-lookup"><span data-stu-id="4ec02-113">Spatial mapping</span></span></td>
        <td><span data-ttu-id="4ec02-114">✔️</span><span class="sxs-lookup"><span data-stu-id="4ec02-114">✔️</span></span></td>
        <td><span data-ttu-id="4ec02-115">✔️</span><span class="sxs-lookup"><span data-stu-id="4ec02-115">✔️</span></span></td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a><span data-ttu-id="4ec02-116">空間マッピングが重要な理由</span><span class="sxs-lookup"><span data-stu-id="4ec02-116">Why is spatial mapping important?</span></span>

<span data-ttu-id="4ec02-117">空間マッピングにより、オブジェクトを実際のサーフェスの上に配置できるようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-117">Spatial mapping makes it possible to place objects on real surfaces.</span></span> <span data-ttu-id="4ec02-118">これは、オブジェクトをユーザーの世界に固定し、実際の深さの手掛かりを活用するのに役立ちます。他のホログラムや実際のオブジェクトに基づいてホログラムを Occluding することで、これらのホログラムが実際に空間にあることをユーザーに納得させることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-118">This helps anchor objects in the user's world and takes advantage of real world depth cues. Occluding your holograms based on other holograms and real world objects helps convince the user that these holograms are actually in their space.</span></span> <span data-ttu-id="4ec02-119">領域内のホログラムまたはユーザーとの移動は実際とは言えません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-119">Holograms floating in space or moving with the user will not feel as real.</span></span> <span data-ttu-id="4ec02-120">可能な場合は、アイテムを快適に配置します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-120">When possible, place items for comfort.</span></span>

<span data-ttu-id="4ec02-121">ホログラムを配置または移動するときにサーフェイスを視覚化します (単純な射影グリッドを使用します)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-121">Visualize surfaces when placing or moving holograms (use a simple projected grid).</span></span> <span data-ttu-id="4ec02-122">これにより、ユーザーがホログラムを最適に配置できる場所を知ることができます。また、ホログラムを配置しようとしている場所がまだマップされていない場合は、ユーザーが表示されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-122">This will help the user know where they can best place their holograms, and shows the user if the spot they are trying to place the hologram hasn't been mapped yet.</span></span> <span data-ttu-id="4ec02-123">角度が非常に多い場合は、ユーザーに "ビルボード項目" を設定できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-123">You can "billboard items" toward the user if they end up at too much of an angle.</span></span>

## <a name="conceptual-overview"></a><span data-ttu-id="4ec02-124">概念の概要</span><span class="sxs-lookup"><span data-stu-id="4ec02-124">Conceptual overview</span></span>

<span data-ttu-id="4ec02-125">部屋](images/SurfaceReconstruction.jpg) をカバーするメッシュサーフェスを ![します</span><span class="sxs-lookup"><span data-stu-id="4ec02-125">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="4ec02-126">*部屋をカバーする空間マッピングメッシュの例*</span><span class="sxs-lookup"><span data-stu-id="4ec02-126">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="4ec02-127">空間マッピングに使用される2つの主なオブジェクトの種類は、"空間サーフェスオブザーバー" と "空間サーフェス" です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-127">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="4ec02-128">アプリケーションは、1つまたは複数の境界ボリュームを持つ空間サーフェスオブザーバーを提供し、アプリケーションが空間マッピングデータを受け取る領域の領域を定義します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-128">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="4ec02-129">これらの各ボリュームについて、空間マッピングによって、空間サーフェスのセットがアプリケーションに提供されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-129">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="4ec02-130">これらのボリュームは、(実際の世界に対して固定された場所で) 静止している場合や、HoloLens にアタッチされている場合があります (これらのボリュームは、環境内を移動するときに HoloLens と一緒に移動されますが、回転しません)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-130">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="4ec02-131">各空間サーフェスは、ワールドロックされた[空間座標系](coordinate-systems.md)に関連付けられた三角形メッシュとして表される、小さい領域の実際のサーフェイスを表します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-131">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="4ec02-132">HoloLens が環境に関する新しいデータを収集すると、環境に対する変更が発生すると、空間サーフェスが表示され、非表示になり、変更されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-132">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a><span data-ttu-id="4ec02-133">空間マッピングとシーンについて WorldMesh を理解する</span><span class="sxs-lookup"><span data-stu-id="4ec02-133">Spatial Mapping vs. Scene Understanding WorldMesh</span></span>
<span data-ttu-id="4ec02-134">HoloLens 2 では、[シーンを理解する SDK](scene-understanding-SDK.md) (EnableWorldMesh 設定) を使用して、空間マッピングデータの静的なバージョンを照会することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-134">For HoloLens 2, it is possible to query a static version of the spatial mapping data using [Scene understanding SDK](scene-understanding-SDK.md) (EnableWorldMesh setting).</span></span> <span data-ttu-id="4ec02-135">空間マッピングデータにアクセスする2つの方法の違いを次に示します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-135">Here are the differences between two way of accessing the spatial mapping data:</span></span>
* <span data-ttu-id="4ec02-136">空間マッピング API:</span><span class="sxs-lookup"><span data-stu-id="4ec02-136">Spatial Mapping API:</span></span>
   * <span data-ttu-id="4ec02-137">制限された範囲: ユーザーに対してキャッシュされた ' バブル ' のサイズで、アプリケーションが使用できる空間マッピングデータ。</span><span class="sxs-lookup"><span data-stu-id="4ec02-137">Limited range: the spatial mapping data available to applications in a limited size cached 'bubble' around the user.</span></span>
   * <span data-ttu-id="4ec02-138">SurfacesChanged イベントによって変更されたメッシュ領域の低待機時間の更新を提供します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-138">Provides low latency updates of changed mesh regions through SurfacesChanged events.</span></span>
   * <span data-ttu-id="4ec02-139">3次測定パラメーターあたりの三角形によって制御される詳細の可変レベル。</span><span class="sxs-lookup"><span data-stu-id="4ec02-139">Variable level of details controlled by Triangles Per Cubic Meter parameter.</span></span>
* <span data-ttu-id="4ec02-140">シーンを理解する SDK:</span><span class="sxs-lookup"><span data-stu-id="4ec02-140">Scene understanding SDK:</span></span>
   * <span data-ttu-id="4ec02-141">無制限の範囲-クエリ radius 内でスキャンされたすべての空間マッピングデータを提供します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-141">Unlimited range - provides all the scanned spatial mapping data within the query radius.</span></span>
   * <span data-ttu-id="4ec02-142">空間マッピングデータの静的なスナップショットを提供します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-142">Provides a static snapshot of the spatial mapping data.</span></span> <span data-ttu-id="4ec02-143">更新された空間マッピングデータを取得するには、メッシュ全体に対して新しいクエリを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-143">Getting the updated spatial mapping data requires running a new query for the whole mesh.</span></span>
   * <span data-ttu-id="4ec02-144">RequestedMeshLevelOfDetail の設定によって制御される詳細レベルの一貫性。</span><span class="sxs-lookup"><span data-stu-id="4ec02-144">Consistent level of details controlled by RequestedMeshLevelOfDetail setting.</span></span>

## <a name="what-influences-spatial-mapping-quality"></a><span data-ttu-id="4ec02-145">空間マッピングの品質に影響を与えるもの</span><span class="sxs-lookup"><span data-stu-id="4ec02-145">What influences spatial mapping quality?</span></span>

<span data-ttu-id="4ec02-146">[ここ](environment-considerations-for-hololens.md)で説明するいくつかの要素は、これらのエラーの頻度と重大度に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-146">Several factors, detailed [here](environment-considerations-for-hololens.md), can affect the frequency and severity of these errors.</span></span>  <span data-ttu-id="4ec02-147">ただし、空間マッピングデータにエラーがある場合でも、ユーザーが目標を達成できるように、アプリケーションを設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-147">However, you should design your application so that the user is able to achieve their goals even in the presence of errors in the spatial mapping data.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="4ec02-148">一般的な利用シナリオ</span><span class="sxs-lookup"><span data-stu-id="4ec02-148">Common usage scenarios</span></span>

![一般的な空間マッピングの使用シナリオの図: 配置、閉鎖、物理、およびナビゲーション](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="4ec02-150">[位置]</span><span class="sxs-lookup"><span data-stu-id="4ec02-150">Placement</span></span>

<span data-ttu-id="4ec02-151">空間マッピングを使用すると、アプリケーションは、自然で使い慣れた形でユーザーと対話することができます。電話をデスクに置いた方が、より自然なことがありますか。</span><span class="sxs-lookup"><span data-stu-id="4ec02-151">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="4ec02-152">サーフェイス上に配置されるホログラム (または、より一般的には、任意の空間位置の選択) の配置を制限すると、3D (空間のポイント) から 2D (サーフェス上の点) への自然なマッピングが実現します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-152">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="4ec02-153">これにより、ユーザーがアプリケーションに提供する必要がある情報の量が削減されるため、ユーザーの操作をより迅速かつ簡単に、より正確に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-153">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="4ec02-154">これは特に、"距離が離れています" が、他の人間やコンピューターと物理的に通信するために使用されるものではないためです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-154">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="4ec02-155">指をポイントすると、方向を指定しますが、距離は指定しません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-155">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="4ec02-156">ここで重要な注意事項として、アプリケーションで方向からの距離が推測される場合 (たとえば、ユーザーの見つめ方向に沿って raycast を実行して最も近い空間サーフェスを検索する場合など)、ユーザーが確実に予測できる結果が得られる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-156">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="4ec02-157">そうしないと、ユーザーは制御の意味を失い、すぐにフラストレーションを受ける可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-157">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="4ec02-158">これに役立つ1つの方法は、1つだけではなく、複数の raycasts を実行することです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-158">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="4ec02-159">集計結果は、より滑らかで予測可能であり、一時的な ' 外れ値 ' 結果からの影響を受けにくくなります (光線が小さな穴を通過するか、ユーザーが認識していないジオメトリの小さなビットに達したことによって発生する可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-159">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="4ec02-160">集計またはスムージングは、時間の経過と共に実行することもできます。たとえば、ホログラムがユーザーからの距離で変化する最大速度を制限できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-160">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="4ec02-161">最小距離と最大距離の値を制限するだけでも役に立ちます。したがって、移動するホログラムは、突然距離が離れたり、ユーザーの顔に戻ったりすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-161">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="4ec02-162">アプリケーションでは、サーフェイスの形状と方向を使用して、ホログラムの配置をガイドすることもできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-162">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="4ec02-163">Holographic チェアは壁を通過しないようにする必要があります。また、やや不均一であっても、床との間にフラッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-163">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="4ec02-164">この種の機能は、単なる raycasts ではなく、物理的な衝突の使用に依存する可能性がありますが、同様の懸念が適用されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-164">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="4ec02-165">配置されているホログラムに、椅子の脚のような小さな多角形が多数含まれている場合は、それらの多角形の物理的な表現をより広い範囲で滑らかに拡張して、空間サーフェスを移動することができます。キャプチャ.</span><span class="sxs-lookup"><span data-stu-id="4ec02-165">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="4ec02-166">極端には、ユーザー入力を完全に簡略化し、空間サーフェスを使用して完全なホログラム配置を実行できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-166">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="4ec02-167">たとえば、アプリケーションでは、ユーザーが押すために壁のどこかに holographic ライトスイッチを配置できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-167">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="4ec02-168">予測可能性に関する注意事項は、ここでは二重に適用されます。ユーザーがホログラムの配置を制御する必要があるものの、アプリケーションが必要な場所にホログラムを配置することがない場合 (ライトスイッチがユーザーに届かない場所に表示される場合)、これは面倒なエクスペリエンスになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-168">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="4ec02-169">実際には、ユーザーが常に配置を実行する必要があるのではなく、ユーザーによる修正を必要とする自動配置を実行する方が悪くなることがあります。自動配置が正常に行われることが*予想*されるため、手動による修正は負担のように感じられます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-169">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="4ec02-170">アプリケーションが空間サーフェスを配置に使用できるかどうかは、アプリケーションの[スキャンエクスペリエンス](spatial-mapping.md#the-environment-scanning-experience)に大きく左右されることにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-170">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="4ec02-171">サーフェイスがスキャンされていない場合は、配置に使用できません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-171">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="4ec02-172">新しい画面をスキャンしたり、新しい場所を選択したりできるように、ユーザーに対してこのことを明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-172">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="4ec02-173">ユーザーへの視覚的なフィードバックは、配置時に非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-173">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="4ec02-174">ユーザーは、最も近い表面と、[接地効果](spatial-mapping.md#visualization)がある場所を認識している必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-174">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="4ec02-175">これらのユーザーは、ホログラムの動きが制約されている理由を理解している必要があります (たとえば、近くにある別のサーフェイスとの衝突が原因で)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-175">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="4ec02-176">現在の場所にホログラムを配置できない場合、視覚的なフィードバックによって、その理由を明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-176">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="4ec02-177">たとえば、ユーザーが壁に holographic ソファを置いている場合、壁の背後にあるソファの部分は、怒った色で色を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-177">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="4ec02-178">反対に、ユーザーが実際の画面を見ることができる場所に空間サーフェイスが見つからない場合は、アプリケーションでこのことを明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-178">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="4ec02-179">この領域での接地効果が明らかでない場合は、この目的を達成することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-179">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="4ec02-180">オクルージョン</span><span class="sxs-lookup"><span data-stu-id="4ec02-180">Occlusion</span></span>

<span data-ttu-id="4ec02-181">空間マッピングサーフェイスの主な用途の1つは、単にホログラムを occlude することです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-181">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="4ec02-182">この単純な動作は、ホログラムのリアリティに大きな影響を与えるため、ユーザーと同じ物理空間をモックとする visceral sense を作成するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-182">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="4ec02-183">また、オクルージョンは、ユーザーに情報を提供します。occluded が本物の表面であると思われる場合、この方法では、世界中のホログラムの空間位置に関する追加の視覚的フィードバックが提供されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-183">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="4ec02-184">逆に、オクルージョンでは、ユーザーからの情報を*非表示*にすることもできます。壁の背後にある occluding ホログラムは、直感的な方法で視覚乱雑を軽減できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-184">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="4ec02-185">ホログラムを表示または非表示にするには、ユーザーは単にヘッドを移動する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-185">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="4ec02-186">また、遮蔽を使用すると、使い慣れた物理的な対話に基づいて自然なユーザーインターフェイスの期待を達成することもできます。ホログラムがサーフェイスによって occluded されている場合、その表面はソリッドであるため、ユーザーは、ホログラムがその表面と*衝突*し、単に通過することを期待する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-186">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="4ec02-187">場合によっては、ホログラムの遮蔽が望ましくないこともあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-187">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="4ec02-188">ユーザーがホログラムを操作できる必要がある場合は、実際の画面の背後にいる場合でも、ユーザーはそれを確認できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-188">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="4ec02-189">このような場合、通常は、occluded したときに (たとえば、明るさを下げることによって) このようなホログラムを別にレンダリングするのが理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="4ec02-189">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="4ec02-190">こうすることで、ユーザーはホログラムを視覚的に見つけることができますが、それでもその背後にあることを認識できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-190">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="4ec02-191">物理</span><span class="sxs-lookup"><span data-stu-id="4ec02-191">Physics</span></span>

<span data-ttu-id="4ec02-192">物理シミュレーションを使用するもう1つの方法として、空間マッピングを使用して、ユーザーの物理空間にホログラムの*存在*を補強することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-192">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="4ec02-193">私の holographic ゴムボールは、机の上から離れたときに、床でバウンスされ、ソファの下に見えなくなったときに、それが本当にないと信じられないかもしれません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-193">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="4ec02-194">また、物理シミュレーションでは、アプリケーションで自然でわかりやすい物理操作を使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-194">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="4ec02-195">フロア上の holographic 家具を移動すると、家具が適切な慣性と摩擦によってフロア上でスライドしているかのように反応する場合、ユーザーにとってはもっと簡単になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-195">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="4ec02-196">現実的な物理的な動作を生成するために、穴の塗りつぶし、浮動 hallucinations の除去、ラフサーフェスのスムージングなど、[メッシュ処理](spatial-mapping.md#mesh-processing)の実行が必要になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-196">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="4ec02-197">また、アプリケーションの[スキャンエクスペリエンス](spatial-mapping.md#the-environment-scanning-experience)が物理シミュレーションに与える影響についても考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-197">You will also need to consider how your application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="4ec02-198">最初は、不足しているサーフェスは何も競合しません。ゴムボールが corridor と、既知の世界の端から離れたときにどうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="4ec02-198">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="4ec02-199">さらに、時間の経過と共に環境の変化に対応するかどうかを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-199">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="4ec02-200">場合によっては、可能な限り迅速に対応する必要があります。たとえば、ユーザーがドアと家具を、barricades の tempest に対する防御の可動として使用しているとします。</span><span class="sxs-lookup"><span data-stu-id="4ec02-200">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="4ec02-201">ただし、場合によっては、新しい更新プログラムを無視することもできます。犬がトラックの途中に座っていると判断した場合、holographic のスポーツ車をフロア上のレースの周りに置いても、突然楽しいことはありません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-201">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="4ec02-202">ナビゲーション</span><span class="sxs-lookup"><span data-stu-id="4ec02-202">Navigation</span></span>

<span data-ttu-id="4ec02-203">アプリケーションでは、空間マッピングデータを使用して、実際の人と同じように、holographic 文字 (またはエージェント) が現実世界に移動できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-203">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="4ec02-204">これにより、ユーザーとその友人と同じ自然でなじみのある動作のセットに制限することで、holographic 文字が確実に存在するようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-204">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="4ec02-205">ナビゲーション機能は、ユーザーにも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-205">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="4ec02-206">特定の領域にナビゲーションマップが構築されると、その場所を知らない新しいユーザーのために holographic の方向を提供するために共有することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-206">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="4ec02-207">このマップは、歩行中のトラフィックの流れを円滑に保つため、または構築サイトなどの危険な場所での事故を防ぐために設計されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-207">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="4ec02-208">ナビゲーション機能の実装に伴う技術的な課題の主な課題は、再生可能なサーフェイス (人間はテーブルをウォークしません) を確実に検出し、環境の変化に適切に適合させることです (人間は閉じたドアをたどることはできません)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-208">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="4ec02-209">メッシュでは、仮想文字によるパスの計画とナビゲーションに使用できるようになる前に、何らかの[処理](spatial-mapping.md#mesh-processing)が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-209">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="4ec02-210">メッシュをスムージングし、hallucinations を削除すると、文字が動かなくなるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-210">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="4ec02-211">また、文字のパス計画とナビゲーションの計算を高速化するために、メッシュを大幅に簡略化することもできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-211">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="4ec02-212">これらの課題は、videogame テクノロジの開発において非常に注意を払ってきました。これらのトピックには、豊富な研究資料があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-212">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="4ec02-213">Unity の組み込みのナビゲーションメッシュ機能は、空間マッピングサーフェイスでは使用できないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-213">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="4ec02-214">これは、アプリケーションが開始されるまで空間マッピングサーフェイスが知られていないのに対して、ナビゲーションデータファイルは事前にソースアセットから生成する必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-214">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="4ec02-215">また、空間マッピングシステムは、ユーザーの現在の場所から離れた場所にある[サーフェイスに関する情報](spatial-mapping.md#the-environment-scanning-experience)を提供しないことにも注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-215">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="4ec02-216">そのため、非常に大きな領域のマップを作成する場合は、アプリケーションがそのサーフェイス自体を記憶する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-216">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="4ec02-217">ビジュアル化</span><span class="sxs-lookup"><span data-stu-id="4ec02-217">Visualization</span></span>

<span data-ttu-id="4ec02-218">ほとんどの場合、空間サーフェスを非表示にするのが適切です。見た目が乱雑にならないようにして、現実世界の声を聞くことができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-218">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="4ec02-219">ただし、実際の対応するものが既に表示されているとしても、空間マッピングサーフェイスを直接視覚化すると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-219">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="4ec02-220">たとえば、ユーザーが表面にホログラムを配置しようとしたとき (壁に holographic キャビネットを配置する場合など)、表面に影をキャストすることによって、ホログラムを "接地" することが役に立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-220">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="4ec02-221">これにより、ホログラムと surface の物理的な距離を明確に理解できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-221">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="4ec02-222">これは、ユーザーがコミットする前に、変更を視覚的に "プレビュー" するより一般的な方法の例でもあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-222">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="4ec02-223">サーフェイスを視覚化することで、アプリケーションは環境についての理解をユーザーと共有できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-223">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="4ec02-224">たとえば、holographic board ゲームでは、"tables" として識別された水平サーフェスを視覚化することができます。これにより、ユーザーが対話する場所を知ることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-224">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="4ec02-225">画面に表示されないユーザーの近くにあるスペースを表示するには、サーフェイスを視覚化すると便利です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-225">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="4ec02-226">これにより、ユーザーがリビングルームからキッチン (およびそのすべてに含まれるホログラム) にアクセスできるようにするための簡単な方法が提供されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-226">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="4ec02-227">空間マッピングによって提供されるサーフェスメッシュは、特に "クリーン" ではない場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-227">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="4ec02-228">したがって、それらを適切に視覚化することが重要です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-228">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="4ec02-229">従来の照明計算では、視覚的には見えない形で表面法線のエラーが強調表示される場合がありますが、画面上に投影された "クリーン" テクスチャは、外観を整えるのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-229">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="4ec02-230">また、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行して、サーフェイスがレンダリングされる前にメッシュのプロパティを向上させることもできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-230">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

> [!NOTE]
> <span data-ttu-id="4ec02-231">HoloLens 2 では、新しいシーンである[ランタイム](scene-understanding.md)を実装しています。これは、配置、閉鎖、物理、およびナビゲーションの実装を簡略化するように設計された、構造化された高レベルの環境表現を使用して、Mixed Reality 開発者に提供します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-231">HoloLens 2 implements a new [Scene Understanding Runtime](scene-understanding.md), that provides Mixed Reality developers with a structured, high-level environment representation designed to simplify the implementation of placement, occlusion, physics and navigation.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="4ec02-232">Surface オブザーバーの使用</span><span class="sxs-lookup"><span data-stu-id="4ec02-232">Using The Surface Observer</span></span>

<span data-ttu-id="4ec02-233">空間マッピングの開始点は、surface オブザーバーです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-233">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="4ec02-234">プログラムフローは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-234">Program flow is as follows:</span></span>
* <span data-ttu-id="4ec02-235">Surface オブザーバーオブジェクトを作成する</span><span class="sxs-lookup"><span data-stu-id="4ec02-235">Create a surface observer object</span></span>
   * <span data-ttu-id="4ec02-236">1つまたは複数の空間ボリュームを指定して、アプリケーションが空間マッピングデータを受け取る対象領域を定義します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-236">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="4ec02-237">空間ボリュームは、球体や箱などの領域の領域を定義する図形です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-237">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="4ec02-238">ワールドロックの空間座標系で空間ボリュームを使用して、物理的な世界の固定領域を特定します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-238">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="4ec02-239">空間ボリュームを使用して、ボディロックされた空間座標系で各フレームを更新し、ユーザーとの間で移動する (ただし、回転しない) 領域を特定します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-239">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="4ec02-240">これらの空間ボリュームは、アプリケーションまたはユーザーの状態が変化したときに、いつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-240">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="4ec02-241">ポーリングまたは通知を使用して空間サーフェスに関する情報を取得する</span><span class="sxs-lookup"><span data-stu-id="4ec02-241">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="4ec02-242">空間サーフェスの状態については、いつでも surface オブザーバーを "ポーリング" できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-242">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="4ec02-243">また、surface オブザーバーの ' surface changed ' イベントに登録することもできます。これにより、空間サーフェスが変化したときにアプリケーションに通知されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-243">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="4ec02-244">ビューが錐である、または本文でロックされているボリュームのような動的な空間ボリュームの場合、アプリケーションは、必要な領域を設定し、現在の空間サーフェスのセットを取得することによって、各フレームの変更に対してポーリングを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-244">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="4ec02-245">1つのルームをカバーするワールドロックキューブなどの静的ボリュームの場合、アプリケーションは、そのボリューム内の空間サーフェスが変更された場合に通知されるように "サーフェイス changed" イベントに登録できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-245">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="4ec02-246">サーフェイスの変化を処理する</span><span class="sxs-lookup"><span data-stu-id="4ec02-246">Process surfaces changes</span></span>
   * <span data-ttu-id="4ec02-247">指定された空間サーフェイスのセットを反復処理します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-247">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="4ec02-248">空間サーフェスを追加、変更、または削除済みとして分類します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-248">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="4ec02-249">追加または変更された空間サーフェイスごとに、必要に応じて、必要な詳細レベルでサーフェイスの現在の状態を表す更新されたメッシュを受け取る非同期要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-249">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="4ec02-250">非同期メッシュ要求を処理します (以降のセクションで詳しく説明します)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-250">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="4ec02-251">メッシュキャッシュ</span><span class="sxs-lookup"><span data-stu-id="4ec02-251">Mesh Caching</span></span>

<span data-ttu-id="4ec02-252">空間サーフェスは、高密度三角形メッシュによって表されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-252">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="4ec02-253">これらのメッシュを格納、表示、および処理すると、コンピューティングリソースとストレージリソースが大幅に消費される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-253">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="4ec02-254">そのため、各アプリケーションは、メッシュの処理とストレージに使用されるリソースを最小限に抑えるために、ニーズに適したメッシュキャッシュ方式を採用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-254">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="4ec02-255">このスキームでは、どのメッシュを保持するか、破棄するか、および各空間サーフェイスのメッシュをいつ更新するかを決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-255">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="4ec02-256">ここで説明する考慮事項の多くは、アプリケーションがメッシュキャッシュにどのように対処する必要があるかを直接通知します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-256">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="4ec02-257">ユーザーが環境内をどのように移動するか、どのサーフェイスが必要であるか、および環境内の変更をいつキャプチャするかを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-257">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="4ec02-258">Surface オブザーバーによって提供される "変化したサーフェイス" イベントを解釈する場合、基本的なメッシュキャッシュのロジックは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-258">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="4ec02-259">前に見られていない空間サーフェス ID がアプリケーションに表示される場合、これを新しい空間サーフェスとして扱います。</span><span class="sxs-lookup"><span data-stu-id="4ec02-259">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="4ec02-260">アプリケーションが既知の ID を持つ空間サーフェスを認識し、新しい更新時間がある場合は、これを更新された空間サーフェスとして扱う必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-260">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="4ec02-261">既知の ID を持つ空間サーフェスがアプリケーションに表示されなくなった場合は、これを削除された空間サーフェスとして扱います。</span><span class="sxs-lookup"><span data-stu-id="4ec02-261">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="4ec02-262">次に、各アプリケーションに対して次の選択を行います。</span><span class="sxs-lookup"><span data-stu-id="4ec02-262">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="4ec02-263">新しい空間サーフェスの場合、メッシュを要求する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="4ec02-263">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="4ec02-264">通常メッシュは、新しい空間サーフェスに対してすぐに要求する必要があります。これにより、ユーザーに有用な新しい情報が提供される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-264">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="4ec02-265">ただし、ユーザーの前と前にある新しい空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-265">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="4ec02-266">新しいメッシュが必要ない場合、たとえば、アプリケーションが環境のモデルを永続的または一時的に "フリーズ" している場合は、そのモデルを要求しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-266">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="4ec02-267">更新された空間サーフェスの場合、メッシュを要求する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="4ec02-267">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="4ec02-268">ユーザーの前と手前にある更新された空間サーフェスに優先順位を付け、そのメッシュを最初に要求する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-268">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="4ec02-269">また、特にスキャンエクスペリエンス中に、更新されたサーフェイスよりも新しいサーフェイスに優先順位を付けることが適切な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-269">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="4ec02-270">処理コストを制限するために、アプリケーションでは、空間サーフェスへの更新を処理する速度を調整することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-270">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="4ec02-271">たとえば、サーフェイスの境界が小さい場合など、空間サーフェスに対する変更は軽微であると推測できます。この場合、更新は処理するのに十分ではない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-271">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="4ec02-272">現在のユーザーの関心領域外の空間サーフェスに対する更新は完全に無視される場合がありますが、この場合は、surface オブザーバーによって使用されている空間境界ボリュームを変更する方が効率的な場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-272">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="4ec02-273">削除された空間サーフェスの場合、メッシュを破棄する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="4ec02-273">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="4ec02-274">通常メッシュは、削除された空間サーフェスに対して直ちに破棄され、ホログラムの閉鎖が適切な状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-274">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="4ec02-275">ただし、アプリケーションが (ユーザーエクスペリエンスの設計に基づいて) 後すぐに空間サーフェスを再表示するという理由がある場合は、メッシュを破棄して後で再作成するよりも、それを保持する方が効率的な場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-275">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="4ec02-276">アプリケーションがユーザーの環境の大規模なモデルを構築している場合、メッシュを破棄したくない場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-276">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="4ec02-277">ただし、空間サーフェスが表示されなくなったときにメッシュをディスクにスプールすることによって、リソースの使用量を制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-277">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="4ec02-278">空間サーフェスの生成中に比較的まれなイベントが発生すると、空間サーフェスが、同じ場所の新しい空間サーフェスに置き換えられることがありますが、Id が異なることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-278">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="4ec02-279">そのため、削除されたサーフェイスを破棄しないことを選択したアプリケーションは、同じ場所をカバーする複数の高重複空間サーフェスメッシュによって終了しないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-279">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="4ec02-280">他の空間サーフェイスではメッシュを破棄する必要がありますか。</span><span class="sxs-lookup"><span data-stu-id="4ec02-280">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="4ec02-281">空間サーフェイスが存在していても、ユーザーのエクスペリエンスには不要になった場合は、破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-281">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="4ec02-282">たとえば、アプリケーションが入室のもう一方の側の部屋を代替仮想空間と置き換える場合、そのルームの空間サーフェスは不要になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-282">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="4ec02-283">次に、空間とテンポラルヒステリシスを使用したメッシュキャッシュ方法の例を示します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-283">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="4ec02-284">アプリケーションでは、ユーザーの宝石に沿って視される、視錐のある空間ボリュームを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-284">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="4ec02-285">空間サーフェスがこのボリュームから一時的に消える可能性があるのは、ユーザーがその画面から離れた場所から離れているためです。後でもう一度参照するか、さらに近い位置に移動します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-285">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="4ec02-286">この場合、このサーフェイスのメッシュを破棄して再作成すると、大量の冗長処理が発生します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-286">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="4ec02-287">処理される変更の数を減らすために、アプリケーションは2つの空間サーフェスオブザーバーを使用します。1つは他方に含まれています。</span><span class="sxs-lookup"><span data-stu-id="4ec02-287">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="4ec02-288">大きいボリュームは球面で、ユーザーの ' 遅延 ' に従います。必要な場合にのみ移動し、そのセンターがユーザーの 2.0 metres 内にあることを確認します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-288">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="4ec02-289">新規および更新された空間サーフェスメッシュは、常に小さい内部サーフェスオブザーバーから処理されますが、メッシュは大きな外部サーフェスオブザーバーから見えなくなるまでキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-289">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="4ec02-290">これにより、アプリケーションは、ローカルユーザーの移動によって多くの冗長な変更を処理することを回避できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-290">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="4ec02-291">空間サーフェスは、追跡が失われることによって一時的に消去される場合もあるため、アプリケーションは、追跡の損失中に削除された空間サーフェスの破棄を延期します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-291">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="4ec02-292">一般に、アプリケーションでは、更新処理の減少とメモリ使用量の増加のトレードオフを評価して、最適なキャッシュ戦略を決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-292">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="4ec02-293">レンダリング</span><span class="sxs-lookup"><span data-stu-id="4ec02-293">Rendering</span></span>

<span data-ttu-id="4ec02-294">空間マッピングメッシュがレンダリングに使用される傾向がある主な方法には、次の3つがあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-294">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="4ec02-295">Surface の視覚化の場合</span><span class="sxs-lookup"><span data-stu-id="4ec02-295">For surface visualization</span></span>
   * <span data-ttu-id="4ec02-296">多くの場合、空間サーフェスを直接視覚化すると便利です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-296">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="4ec02-297">たとえば、オブジェクトから空間サーフェスに ' shadows ' をキャストすると、サーフェイスにホログラムを配置するときに、視覚的なフィードバックをユーザーに提供できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-297">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="4ec02-298">空間メッシュは、3D アーティストによって作成されるメッシュの種類とは異なる点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-298">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="4ec02-299">トライアングルトポロジは人間が作成したトポロジとして "クリーン" ではなく、メッシュが[さまざまなエラー](spatial-mapping.md#what-influences-spatial-mapping-quality)によって影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-299">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="4ec02-300">見栄えの良いビジュアルを作成するには、穴や smooth surface の法線を塗りつぶすなど、[メッシュ処理](spatial-mapping.md#mesh-processing)を実行することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-300">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="4ec02-301">また、メッシュトポロジや法線を直接視覚化するのではなく、シェーダーを使用して、アーティストによって設計されたテクスチャをメッシュに射影することもできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-301">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="4ec02-302">実際のサーフェイスの背後にある occluding ホログラムの場合</span><span class="sxs-lookup"><span data-stu-id="4ec02-302">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="4ec02-303">空間サーフェスは、[深度バッファー](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)にのみ影響を与え、カラーレンダーターゲットには影響しない、深度のみのパスでレンダリングできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-303">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="4ec02-304">これにより、空間サーフェスの背後でレンダリングされるホログラムを occlude するための深度バッファーが primes されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-304">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="4ec02-305">ホログラムを正確に遮蔽することで、ユーザーの物理的な領域内にホログラムが本当に存在するという意味が高まります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-305">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="4ec02-306">深度のみのレンダリングを有効にするには、blend の状態を更新して、すべてのカラーレンダーターゲットで[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)を0に設定します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-306">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="4ec02-307">実際のサーフェイスによるホログラム occluded の外観を変更するには</span><span class="sxs-lookup"><span data-stu-id="4ec02-307">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="4ec02-308">通常表示されるジオメトリは、occluded すると非表示になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-308">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="4ec02-309">これを実現するには、深度ステンシルの[状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)の depth 関数を "次の値以下" に設定します。これにより、以前にレンダリングされたすべてのジオメトリよりもカメラに**近い**場所にのみジオメトリが表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-309">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="4ec02-310">ただし、特定のジオメトリが occluded されていても表示されないようにしたり、視覚的なフィードバックをユーザーに提供する手段として occluded したときの外観を変更したりすると便利な場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-310">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="4ec02-311">たとえば、これにより、アプリケーションは、実際の画面の背後にあることを明確にしながら、オブジェクトの場所をユーザーに表示できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-311">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="4ec02-312">これを実現するには、必要な ' occluded ' 外観を作成する別のシェーダーを使用して、ジオメトリをもう一度描画します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-312">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="4ec02-313">2回目のジオメトリをレンダリングする前に、[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)に2つの変更を加えます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-313">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="4ec02-314">最初に、深度関数を "以上" に設定します。これにより、ジオメトリは、**以前にレンダリングされ**たすべてのジオメトリよりもカメラから見た場合にのみ表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-314">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="4ec02-315">次に、DepthWriteMask を0に設定して、深度バッファーが変更されないようにします (深度バッファーは、カメラに**最も近い**ジオメトリの深さを継続して表す必要があります)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-315">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="4ec02-316">空間マッピングメッシュをレンダリングする場合、[パフォーマンス](understanding-performance-for-mixed-reality.md)は重要な問題です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-316">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="4ec02-317">空間マッピングメッシュのレンダリングに固有のレンダリングパフォーマンス手法を次に示します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-317">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="4ec02-318">三角形の密度を調整する</span><span class="sxs-lookup"><span data-stu-id="4ec02-318">Adjust triangle density</span></span>
   * <span data-ttu-id="4ec02-319">Surface オブザーバーから空間サーフェスメッシュを要求するときは、必要に応じて十分な三角形メッシュの最低密度を要求します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-319">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="4ec02-320">画面上の三角形の密度は、ユーザーからの距離とユーザーエクスペリエンスに対する関係に応じて、サーフェス単位で変化させることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-320">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="4ec02-321">トライアングル数を減らすと、GPU のメモリ使用量と頂点処理コストが削減されますが、ピクセル処理のコストには影響しません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-321">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="4ec02-322">錐のあるカリングを実行する</span><span class="sxs-lookup"><span data-stu-id="4ec02-322">Perform frustum culling</span></span>
   * <span data-ttu-id="4ec02-323">視錐台のカリングは、表示できない描画オブジェクトをスキップします。これは、現在のディスプレイが視錐であるためです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-323">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="4ec02-324">これにより、CPU と GPU の両方の処理コストが削減されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-324">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="4ec02-325">カリングはメッシュごとに実行されるため、空間サーフェスは大きくなる可能性があるため、各空間サーフェスメッシュを小さなチャンクに分割すると、より効率的なカリングを実現できます (オフスクリーンの三角形がレンダリングされます)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-325">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="4ec02-326">ただし、トレードオフがあります。メッシュ数が多いほど描画呼び出しが多くなるため、CPU コストが増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-326">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="4ec02-327">極端なケースでは、錐のあるカリングの計算自体が、測定可能な CPU コストを持つことさえあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-327">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="4ec02-328">レンダリング順序の調整</span><span class="sxs-lookup"><span data-stu-id="4ec02-328">Adjust rendering order</span></span>
   * <span data-ttu-id="4ec02-329">空間サーフェスは、周囲のユーザーの環境全体を表しているため、サイズが大きくなる傾向があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-329">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="4ec02-330">これにより、GPU のピクセル処理コストが高くなる可能性があります。これは特に、可視ジオメトリのレイヤーが複数存在する場合 (空間サーフェスとその他のホログラムを含む) の場合に特に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-330">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="4ec02-331">この場合、ユーザーに最も近いレイヤーはさらにレイヤーを occluding するため、遠くのレイヤーをレンダリングするのに費やされた GPU 時間は無駄になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-331">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="4ec02-332">GPU 上のこの冗長な作業を減らすために、不透明なサーフェスを前方から後方にレンダリングするのに役立ちます (先に近い順にします)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-332">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="4ec02-333">' 不透明 ' では、DepthWriteMask が[深度ステンシルの状態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)で1に設定されているサーフェイスを意味します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-333">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="4ec02-334">最も近いサーフェイスがレンダリングされると、GPU のピクセルプロセッサによって遠く離れたサーフェイスが効率的にスキップされるように、深度バッファーが最適になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-334">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="4ec02-335">メッシュ処理</span><span class="sxs-lookup"><span data-stu-id="4ec02-335">Mesh Processing</span></span>

<span data-ttu-id="4ec02-336">アプリケーションでは、必要に応じて、空間サーフェスメッシュに対して[さまざまな操作](spatial-mapping.md#mesh-processing)を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-336">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="4ec02-337">各空間サーフェスメッシュで提供されるインデックスおよび頂点データは、すべての最新のレンダリング Api で三角形メッシュをレンダリングするために使用される[頂点およびインデックスバッファー](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)と同じ使い慣れたレイアウトを使用します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-337">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="4ec02-338">ただし、重要な1つの重要な点は、空間マッピングの三角形には、**反時計回りの回転順序**があるということです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-338">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="4ec02-339">各三角形はメッシュのインデックスバッファー内の3つの頂点インデックスによって表されます。これらのインデックスは、三角形が**正面**から表示されるときに、三角形の頂点を**時計回り**の順序で識別します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-339">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="4ec02-340">空間サーフェスメッシュの前面 (または外側) は、実際のサーフェイスの前面 (表示されている側) に期待されるように対応します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-340">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="4ec02-341">アプリケーションでは、surface オブザーバーによって提供される coarsest 三角形の密度がまだ粗いことがない場合にのみメッシュの単純化を実行する必要があります。この作業は負荷が高く、ランタイムがさまざまなを生成するために既に実行されています。提供される詳細レベル。</span><span class="sxs-lookup"><span data-stu-id="4ec02-341">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="4ec02-342">各サーフェイスオブザーバーは複数の未接続空間サーフェスを提供できるため、アプリケーションによっては、これらの空間サーフェスメッシュを相互にクリップし、それらをまとめて zipper ことが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-342">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="4ec02-343">一般的に、隣接する空間サーフェスメッシュが少し重なっているため、クリッピング手順が必要です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-343">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="4ec02-344">Raycasting と競合</span><span class="sxs-lookup"><span data-stu-id="4ec02-344">Raycasting and Collision</span></span>

<span data-ttu-id="4ec02-345">アプリケーションで空間サーフェスの raycasting および衝突機能を使用できるようにするために、物理 API (の場合は、等[ok](https://www.havok.com/)) では、アプリケーションで物理 api に空間サーフェスメッシュを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-345">In order for a physics API (such as [Havok](https://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="4ec02-346">物理に使用されるメッシュには、次の特性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-346">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="4ec02-347">これらには、少数の三角形しか含まれていません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-347">They contain only small numbers of triangles.</span></span> <span data-ttu-id="4ec02-348">物理操作は、レンダリング操作よりも計算が多くなります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-348">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="4ec02-349">このような場合は、"水がきつい" になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-349">They are 'water-tight'.</span></span> <span data-ttu-id="4ec02-350">ソリッドであることを意図したサーフェスは、小さな穴を持つことはできません。表示できない穴が小さすぎる場合でも、問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-350">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="4ec02-351">これらは、凸状 hulls に変換されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-351">They are converted into convex hulls.</span></span> <span data-ttu-id="4ec02-352">凸状の hulls にはいくつかのポリゴンがあり、穴は不要であり、生の三角形メッシュよりも処理がはるかに効率的です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-352">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="4ec02-353">空間サーフェスに対して raycasts を実行するときは、机のように、これらのサーフェスが複雑で、乱雑なものではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-353">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="4ec02-354">つまり、1つの raycast では、画面の形状や、その近くにある空の領域の形状に関する十分な情報を得ることができません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-354">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="4ec02-355">そのため、通常は小さな領域内で多くの raycasts を実行し、集計結果を使用して、より信頼性の高いサーフェイスの理解を得ることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4ec02-355">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="4ec02-356">たとえば、平均 10 raycasts を使用して、表面にホログラムの配置を行うと、1つの raycast だけを使用して、はるかに滑らかで "ちらつき" の結果が得られます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-356">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="4ec02-357">ただし、raycast ごとに計算コストが高くなる可能性があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-357">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="4ec02-358">したがって、使用シナリオによっては、(すべてのフレームで実行される) 追加の raycasts の計算コストと[メッシュ処理](spatial-mapping.md#mesh-processing)の計算コストを比較して、空間サーフェスの穴を滑らかにしたり削除したりする必要があります (空間メッシュを更新したときに実行されます)。</span><span class="sxs-lookup"><span data-stu-id="4ec02-358">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="the-environment-scanning-experience"></a><span data-ttu-id="4ec02-359">環境のスキャンエクスペリエンス</span><span class="sxs-lookup"><span data-stu-id="4ec02-359">The environment scanning experience</span></span>

<span data-ttu-id="4ec02-360">空間マッピングを使用する各アプリケーションでは、"スキャンエクスペリエンス" を提供することを検討する必要があります。アプリケーションが正常に機能するために必要なサーフェイスをスキャンするためにアプリケーションがユーザーに指示するプロセス。</span><span class="sxs-lookup"><span data-stu-id="4ec02-360">Each application that uses spatial mapping should consider providing a 'scanning experience'; the process through which the application guides the user to scan surfaces that are necessary for the application to function correctly.</span></span>

<span data-ttu-id="4ec02-361">スキャン](images/sr-mixedworld-140429-8pm-00068-1000px.png) の ![例</span><span class="sxs-lookup"><span data-stu-id="4ec02-361">![Example of scanning](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span></span><br>
<span data-ttu-id="4ec02-362">*スキャンの例*</span><span class="sxs-lookup"><span data-stu-id="4ec02-362">*Example of scanning*</span></span>

<span data-ttu-id="4ec02-363">このスキャンエクスペリエンスの性質は、アプリケーションのニーズによって大きく異なる場合がありますが、主に2つの原則として設計を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-363">The nature of this scanning experience can vary greatly depending upon each application's needs, but two main principles should guide its design.</span></span>

<span data-ttu-id="4ec02-364">まず、**ユーザーとの通信をクリア**します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-364">Firstly, **clear communication with the user is the primary concern**.</span></span> <span data-ttu-id="4ec02-365">ユーザーは、アプリケーションの要件が満たされているかどうかを常に把握している必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-365">The user should always be aware of whether the application's requirements are being met.</span></span> <span data-ttu-id="4ec02-366">これらが満たされていない場合は、その理由をユーザーにすぐに明確にする必要があります。また、適切な操作を行うための迅速な対応が必要になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-366">When they are not being met, it should be immediately clear to the user why this is so and they should be quickly led to take the appropriate action.</span></span>

<span data-ttu-id="4ec02-367">また、**アプリケーションは、効率性と信頼性のバランスを取るように試み**ます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-367">Secondly, **applications should attempt to strike a balance between efficiency and reliability**.</span></span> <span data-ttu-id="4ec02-368">**信頼性**を高めるために、アプリケーションでは、ユーザー時間を節約するために、空間マッピングデータを自動的に分析する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-368">When it is possible to do so **reliably**, applications should automatically analyze spatial mapping data to save the user time.</span></span> <span data-ttu-id="4ec02-369">信頼性を高めることができない場合は、アプリケーションでは、アプリケーションに必要な追加情報を迅速に提供できるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-369">When it is not possible to do so reliably, applications should instead enable the user to quickly provide the application with the additional information it requires.</span></span>

<span data-ttu-id="4ec02-370">適切なスキャンエクスペリエンスを設計するために、アプリケーションに適用できる次のような可能性を検討してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-370">To help design the right scanning experience, consider which of the following possibilities are applicable to your application:</span></span>

* <span data-ttu-id="4ec02-371">**スキャンエクスペリエンスがありません**</span><span class="sxs-lookup"><span data-stu-id="4ec02-371">**No scanning experience**</span></span>
   * <span data-ttu-id="4ec02-372">アプリケーションは、ガイド付きスキャンを使用しなくても完璧に機能します。自然なユーザー移動の過程で観察されたサーフェイスについて説明します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-372">An application may function perfectly without any guided scanning experience; it will learn about surfaces that are observed in the course of natural user movement.</span></span>
   * <span data-ttu-id="4ec02-373">たとえば、ユーザーが holographic スプレーペイントを使用してサーフェイス上に描画できるようにするアプリケーションでは、ユーザーに現在表示されているサーフェイスの知識のみが必要です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-373">For example an application that lets the user draw on surfaces with holographic spray paint requires knowledge only of the surfaces currently visible to the user.</span></span>
   * <span data-ttu-id="4ec02-374">ユーザーが HoloLens を使用して既に多数の時間を費やしている場合、環境は既に完全にスキャンされている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-374">The environment may be completely scanned already if it is one in which the user has already spent a lot of time using the HoloLens.</span></span>
   * <span data-ttu-id="4ec02-375">ただし、空間マッピングによって使用されるカメラでは、ユーザーの前に 3.1 m しか表示されないことに注意してください。そのため、ユーザーが過去の距離を超えていない限り、空間マッピングは遠く離れたサーフェイスを認識しません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-375">Bear in mind however that the camera used by spatial mapping can only see 3.1m in front of the user, so spatial mapping will not know about any more distant surfaces unless the user has observed them from a closer distance in the past.</span></span>
   * <span data-ttu-id="4ec02-376">スキャンされたサーフェイスをユーザーが理解できるように、アプリケーションはこの効果に対して視覚的なフィードバックを提供する必要があります。たとえば、仮想シャドウをスキャンしたサーフェイスにキャストすると、ユーザーがこれらのサーフェイスにホログラムを配置するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-376">So the user understands which surfaces have been scanned, the application should provide visual feedback to this effect, for example casting virtual shadows onto scanned surfaces may help the user place holograms on those surfaces.</span></span>
   * <span data-ttu-id="4ec02-377">この場合、空間サーフェスオブザーバーの境界ボリュームは、各フレームを本文ロックされた[空間座標系](coordinate-systems.md)に更新して、ユーザーがフォローするようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-377">For this case, the spatial surface observer's bounding volumes should be updated each frame to a body-locked [spatial coordinate system](coordinate-systems.md), so that they follow the user.</span></span>

* <span data-ttu-id="4ec02-378">**適切な場所の検索**</span><span class="sxs-lookup"><span data-stu-id="4ec02-378">**Find a suitable location**</span></span>
   * <span data-ttu-id="4ec02-379">アプリケーションは、特定の要件を持つ場所で使用するように設計されている場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-379">An application may be designed for use in a location with specific requirements.</span></span>
   * <span data-ttu-id="4ec02-380">たとえば、アプリケーションでは、holographic kung-fu を安全に実行できるように、ユーザーの周囲に空の領域が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-380">For example, the application may require an empty area around the user so they can safely practice holographic kung-fu.</span></span>
   * <span data-ttu-id="4ec02-381">アプリケーションでは、特定の要件をユーザーに事前に伝え、視覚的なフィードバックを明確にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-381">Applications should communicate any specific requirements to the user up-front, and reinforce them with clear visual feedback.</span></span>
   * <span data-ttu-id="4ec02-382">この例では、アプリケーションは必要な空の領域の範囲を視覚化し、このゾーン内の不要なオブジェクトの存在を視覚的に強調表示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-382">In this example, the application should visualize the extent of the required empty area and visually highlight the presence of any undesired objects within this zone.</span></span>
   * <span data-ttu-id="4ec02-383">この場合、空間サーフェスのオブザーバーの境界ボリュームは、選択した場所でワールドロックの[空間座標系](coordinate-systems.md)を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-383">For this case, the spatial surface observer's bounding volumes should use a world-locked [spatial coordinate system](coordinate-systems.md) in the chosen location.</span></span>

* <span data-ttu-id="4ec02-384">**サーフェイスの適切な構成を見つける**</span><span class="sxs-lookup"><span data-stu-id="4ec02-384">**Find a suitable configuration of surfaces**</span></span>
   * <span data-ttu-id="4ec02-385">アプリケーションでは、たとえば、2つの大規模なフラットな壁面の壁を作るために、特定のサーフェイスの構成が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-385">An application may require a specific configuration of surfaces, for example two large, flat, opposing walls to create a holographic hall of mirrors.</span></span>
   * <span data-ttu-id="4ec02-386">このような場合、アプリケーションでは、空間マッピングによって提供されるサーフェスを分析して適切なサーフェイスを検出し、ユーザーに対してユーザーに指示する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-386">In such cases the application will need to analyze the surfaces provided by spatial mapping to detect suitable surfaces, and direct the user toward them.</span></span>
   * <span data-ttu-id="4ec02-387">アプリケーションのサーフェイス分析が完全に信頼できない場合は、フォールバックオプションが必要です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-387">The user should have a fallback option if the application's surface analysis is not completely reliable.</span></span> <span data-ttu-id="4ec02-388">たとえば、アプリケーションで入室がフラットな壁として誤って識別される場合、このエラーを修正するための簡単な方法が必要になります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-388">For example, if the application incorrectly identifies a doorway as a flat wall, the user needs a simple way to correct this error.</span></span>

* <span data-ttu-id="4ec02-389">**環境の一部をスキャンする**</span><span class="sxs-lookup"><span data-stu-id="4ec02-389">**Scan part of the environment**</span></span>
   * <span data-ttu-id="4ec02-390">アプリケーションでは、ユーザーの指示に従って、環境の一部のみをキャプチャすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4ec02-390">An application may wish to only capture part of the environment, as directed by the user.</span></span>
   * <span data-ttu-id="4ec02-391">たとえば、アプリケーションは部屋の一部をスキャンするので、ユーザーが販売する家具用に分類された holographic 広告を投稿することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-391">For example, the application scans part of a room so the user may post a holographic classified ad for furniture they wish to sell.</span></span>
   * <span data-ttu-id="4ec02-392">この場合、アプリケーションは、スキャン中にユーザーによって監視されているリージョン内の空間マッピングデータをキャプチャする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-392">In this case, the application should capture spatial mapping data within the regions observed by the user during their scan.</span></span>

* <span data-ttu-id="4ec02-393">**部屋全体をスキャンする**</span><span class="sxs-lookup"><span data-stu-id="4ec02-393">**Scan the whole room**</span></span>
   * <span data-ttu-id="4ec02-394">アプリケーションでは、ユーザーの背後にあるものも含め、現在の部屋にあるすべてのサーフェイスのスキャンが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-394">An application may require a scan of all of the surfaces in the current room, including those behind the user.</span></span>
   * <span data-ttu-id="4ec02-395">たとえば、ゲームでは、すべての方向から何百もの Lilliputians が発生した場合に、ユーザーを Gulliver のロールに配置することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-395">For example, a game may put the user in the role of Gulliver, under siege from hundreds of tiny Lilliputians approaching from all directions.</span></span>
   * <span data-ttu-id="4ec02-396">このような場合、アプリケーションは、現在の部屋に既にスキャンされているサーフェイスの数を判断し、大きなギャップを埋めるようにユーザーの宝石を誘導する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-396">In such cases, the application will need to determine how many of the surfaces in the current room have already been scanned, and direct the user's gaze to fill in significant gaps.</span></span>
   * <span data-ttu-id="4ec02-397">このプロセスの重要なのは、まだスキャンされていないサーフェイスをユーザーに明確にするための視覚的なフィードバックを提供することです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-397">The key to this process is providing visual feedback that makes it clear to the user which surfaces have not yet been scanned.</span></span> <span data-ttu-id="4ec02-398">アプリケーションでは、[距離ベースのフォグ](https://msdn.microsoft.com/library/windows/desktop/bb173401%28v=vs.85%29.aspx)を使用して、空間マッピングサーフェイスでカバーされていない領域を視覚的に強調することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-398">The application could for example use [distance-based fog](https://msdn.microsoft.com/library/windows/desktop/bb173401%28v=vs.85%29.aspx) to visually highlight regions that are not covered by spatial mapping surfaces.</span></span>

* <span data-ttu-id="4ec02-399">**環境の初期スナップショットを取得する**</span><span class="sxs-lookup"><span data-stu-id="4ec02-399">**Take an initial snapshot of the environment**</span></span>
   * <span data-ttu-id="4ec02-400">アプリケーションでは、初期の "スナップショット" を取得した後、環境内のすべての変更を無視することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-400">An application may wish to ignore all changes in the environment after taking an initial 'snapshot'.</span></span>
   * <span data-ttu-id="4ec02-401">これは、ユーザーが作成した、環境の初期状態と密接に結び付いているデータの中断を回避するために適している場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-401">This may be appropriate to avoid disruption of user-created data that is tightly coupled to the initial state of the environment.</span></span>
   * <span data-ttu-id="4ec02-402">この場合、アプリケーションは、スキャンが完了したら、初期状態で空間マッピングデータのコピーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-402">In this case, the application should make a copy of the spatial mapping data in its initial state once the scan is complete.</span></span>
   * <span data-ttu-id="4ec02-403">環境によってホログラムが正しく occluded されていない場合、アプリケーションは空間マッピングデータへの更新の受信を続行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-403">Applications should continue receiving updates to spatial mapping data if holograms are still to be correctly occluded by the environment.</span></span>
   * <span data-ttu-id="4ec02-404">空間マッピングデータを継続的に更新することで、発生したすべての変更を視覚化することができ、環境の以前の状態と現在の状態の違いをユーザーに明確にすることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-404">Continued updates to spatial mapping data also allow visualizing any changes that have occurred, clarifying to the user the differences between prior and present states of the environment.</span></span>

* <span data-ttu-id="4ec02-405">**環境のユーザーが開始したスナップショットを取得する**</span><span class="sxs-lookup"><span data-stu-id="4ec02-405">**Take user-initiated snapshots of the environment**</span></span>
   * <span data-ttu-id="4ec02-406">アプリケーションでは、ユーザーによって指示された場合にのみ、環境の変更に応答する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-406">An application may only wish to respond to environmental changes when instructed by the user.</span></span>
   * <span data-ttu-id="4ec02-407">たとえば、ユーザーは、さまざまな瞬間にその場所をキャプチャすることにより、友人の複数の 3D ' statues ' を作成できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-407">For example, the user could create multiple 3D 'statues' of a friend by capturing their poses at different moments.</span></span>

* <span data-ttu-id="4ec02-408">**ユーザーが環境を変更できるようにする**</span><span class="sxs-lookup"><span data-stu-id="4ec02-408">**Allow the user to change the environment**</span></span>
   * <span data-ttu-id="4ec02-409">アプリケーションは、ユーザーの環境で行われた変更にリアルタイムで応答するように設計されている場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-409">An application may be designed to respond in real-time to any changes made in the user's environment.</span></span>
   * <span data-ttu-id="4ec02-410">たとえば、curtain を描画したユーザーは、holographic play に対して "シーンの変更" をトリガーできます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-410">For example, the user drawing a curtain could trigger 'scene change' for a holographic play taking place on the other side.</span></span>

* <span data-ttu-id="4ec02-411">**空間マッピングデータのエラーを回避するためのユーザーガイド**</span><span class="sxs-lookup"><span data-stu-id="4ec02-411">**Guide the user to avoid errors in the spatial mapping data**</span></span>
   * <span data-ttu-id="4ec02-412">アプリケーションでは、環境のスキャン中にユーザーにガイダンスを提供することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-412">An application may wish to provide guidance to the user while they are scanning their environment.</span></span>
   * <span data-ttu-id="4ec02-413">これにより、ユーザーは、sunlit のウィンドウやミラーを離れるなどして、[空間マッピングデータ内](spatial-mapping.md#what-influences-spatial-mapping-quality)の特定の種類のエラーを回避できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-413">This can help the user to avoid certain kinds of [errors in the spatial mapping data](spatial-mapping.md#what-influences-spatial-mapping-quality), for example by staying away from sunlit windows or mirrors.</span></span>

<span data-ttu-id="4ec02-414">注意すべきもう1つの詳細は、空間マッピングデータの "範囲" が無制限ではないことです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-414">One additional detail to be aware of is that the 'range' of spatial mapping data is not unlimited.</span></span> <span data-ttu-id="4ec02-415">空間マッピングでは、大きなスペースの永続的なデータベースが構築されますが、ユーザーの周囲のサイズが制限された ' バブル ' では、アプリケーションでそのデータを使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-415">Whilst spatial mapping does build a permanent database of large spaces, it only makes that data available to applications in a 'bubble' of limited size around the user.</span></span> <span data-ttu-id="4ec02-416">したがって、長い corridor の先頭から開始して、開始から十分な距離が得られない場合は、最終的に空間サーフェスが先頭に戻ることになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-416">Thus if you start at the beginning of a long corridor and walk far enough away from the start, then eventually the spatial surfaces back at the beginning will disappear.</span></span> <span data-ttu-id="4ec02-417">もちろん、これらのサーフェイスは、使用可能な空間マッピングデータから消滅した後で、アプリケーションにキャッシュすることで軽減できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-417">You can of course mitigate this by caching those surfaces in your application after they have disappeared from the available spatial mapping data.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="4ec02-418">メッシュ処理</span><span class="sxs-lookup"><span data-stu-id="4ec02-418">Mesh processing</span></span>

<span data-ttu-id="4ec02-419">これは、サーフェイス内の一般的なエラーの種類を検出し、必要に応じて空間マッピングデータをフィルター処理、削除、または変更するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-419">It may help to detect common types of errors in surfaces and to filter, remove or modify the spatial mapping data as appropriate.</span></span>

<span data-ttu-id="4ec02-420">空間マッピングデータは、実際のサーフェイスにできるだけ忠実として使用することを想定しているので、どのような処理を適用しても、画面が "真実" からさらに変化することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-420">Bear in mind that spatial mapping data is intended to be as faithful as possible to real-world surfaces, so any processing you apply risks shifting your surfaces further from the 'truth'.</span></span>

<span data-ttu-id="4ec02-421">役に立つ可能性があるさまざまな種類のメッシュ処理の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-421">Here are some examples of different types of mesh processing that you may find useful:</span></span>

* <span data-ttu-id="4ec02-422">**穴の塗りつぶし**</span><span class="sxs-lookup"><span data-stu-id="4ec02-422">**Hole filling**</span></span>
   * <span data-ttu-id="4ec02-423">ダークマテリアルで作成された小さなオブジェクトがスキャンに失敗した場合、周囲のサーフェイスに穴が残されます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-423">If a small object made of a dark material fails to scan, it will leave a hole in the surrounding surface.</span></span>
   * <span data-ttu-id="4ec02-424">穴はオクルージョンに影響します。ホログラムは、不透明な現実世界の表面に穴を表示できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-424">Holes affect occlusion: holograms can be seen 'through' a hole in a supposedly opaque real-world surface.</span></span>
   * <span data-ttu-id="4ec02-425">穴は raycasts に影響します。ユーザーがサーフェイスを操作するために raycasts を使用している場合、これらの光線が穴を通過することは望ましくありません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-425">Holes affect raycasts: if you are using raycasts to help users interact with surfaces, it may be undesirable for these rays to pass through holes.</span></span> <span data-ttu-id="4ec02-426">軽減策の1つは、適切にサイズ設定されたリージョンをカバーする複数の raycasts のバンドルを使用することです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-426">One mitigation is to use a bundle of multiple raycasts covering an appropriately sized region.</span></span> <span data-ttu-id="4ec02-427">これにより、"外れ値" の結果をフィルター処理して、1つの raycast が小さな穴を通過した場合でも、集計結果が引き続き有効になるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-427">This will allow you to filter 'outlier' results, so that even if one raycast passes through a small hole, the aggregate result will still be valid.</span></span> <span data-ttu-id="4ec02-428">ただし、このアプローチには計算コストがかかることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-428">However, be aware that this approach comes at a computational cost.</span></span>
   * <span data-ttu-id="4ec02-429">穴は物理的な衝突に影響します。物理シミュレーションによって制御されるオブジェクトは、床の穴を通過して失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-429">Holes affect physics collisions: an object controlled by physics simulation may drop through a hole in the floor and become lost.</span></span>
   * <span data-ttu-id="4ec02-430">Surface メッシュでは、このような穴をアルゴリズムに塗りつぶすことができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-430">It is possible to algorithmically fill such holes in the surface mesh.</span></span> <span data-ttu-id="4ec02-431">ただし、windows や doorways などの "実際のホール" が入力されないように、アルゴリズムを調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-431">However, you will need to tune your algorithm so that 'real holes' such as windows and doorways do not get filled in.</span></span> <span data-ttu-id="4ec02-432">' 実際のホール ' を ' 虚数穴 ' から確実に区別することは困難であるため、' size ' や ' 境界図形 ' などのさまざまなヒューリスティックを試してみる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-432">It can be difficult to reliably differentiate 'real holes' from 'imaginary holes', so you will need to experiment with different heuristics such as 'size' and 'boundary shape'.</span></span>

* <span data-ttu-id="4ec02-433">**Hallucination の削除**</span><span class="sxs-lookup"><span data-stu-id="4ec02-433">**Hallucination removal**</span></span>
   * <span data-ttu-id="4ec02-434">反射、明るいライト、およびオブジェクトの移動は、中程度の小さな残留物を維持することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-434">Reflections, bright lights and moving objects can leave small lingering 'hallucinations' floating in mid-air.</span></span>
   * <span data-ttu-id="4ec02-435">Hallucinations への影響の影響: Hallucinations は、他のホログラムの前に移動するダークシェイプとして表示されることがあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-435">Hallucinations affect occlusion: hallucinations may become visible as dark shapes moving in front of and occluding other holograms.</span></span>
   * <span data-ttu-id="4ec02-436">Hallucinations は raycasts に影響します。 raycasts を使用してユーザーがサーフェイスを操作できるようにする場合、これらの光線は、背後にある表面ではなく hallucination にヒットする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-436">Hallucinations affect raycasts: if you are using raycasts to help users interact with surfaces, these rays could hit a hallucination instead of the surface behind it.</span></span> <span data-ttu-id="4ec02-437">穴の場合と同様に、1つの raycast ではなく多くの raycasts を使用することができますが、この場合も計算コストが発生します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-437">As with holes, one mitigation is to use many raycasts instead of a single raycast, but again this will come at a computational cost.</span></span>
   * <span data-ttu-id="4ec02-438">Hallucinations は、物理的な衝突に影響を与えます。物理シミュレーションによって制御されるオブジェクトは、hallucination に対してスタックし、一見した領域の領域を移動できなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-438">Hallucinations affect physics collisions: an object controlled by physics simulation may become stuck against a hallucination and be unable to move through a seemingly clear area of space.</span></span>
   * <span data-ttu-id="4ec02-439">Surface メッシュからこのような hallucinations をフィルター処理できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-439">It is possible to filter such hallucinations from the surface mesh.</span></span> <span data-ttu-id="4ec02-440">ただし、穴の場合と同様に、照明とドアハンドルなどの実際の小さなオブジェクトが削除されないように、アルゴリズムを調整する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-440">However, as with holes, you will need to tune your algorithm so that real small objects such as lamp-stands and door handles do not get removed.</span></span>

* <span data-ttu-id="4ec02-441">**滑らかさ**</span><span class="sxs-lookup"><span data-stu-id="4ec02-441">**Smoothing**</span></span>
   * <span data-ttu-id="4ec02-442">空間マッピングは、実際の対応するものと比較して、粗いまたは "雑音" のように見える表面を返すことがあります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-442">Spatial mapping may return surfaces that appear to be rough or 'noisy' in comparison to their real-world counterparts.</span></span>
   * <span data-ttu-id="4ec02-443">滑らかさは、物理的な衝突に影響します。フロアが粗い場合は、物理的にシミュレートされたゴルフボールが直線内でスムーズにロールすることはできません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-443">Smoothness affects physics collisions: if the floor is rough, a physically simulated golf ball may not roll smoothly across it in a straight line.</span></span>
   * <span data-ttu-id="4ec02-444">滑らかさはレンダリングに影響します。表面が直接視覚化されている場合、表面法線の外観が影響を受けることがあり、' クリーン ' の外観が中断される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-444">Smoothness affects rendering: if a surface is visualized directly, rough surface normals can affect its appearance and disrupt a 'clean' look.</span></span> <span data-ttu-id="4ec02-445">サーフェイスのレンダリングに使用されるシェーダー内の適切な光源とテクスチャを使用することによって、これを軽減することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-445">It is possible to mitigate this by using appropriate lighting and textures in the shader that is used to render the surface.</span></span>
   * <span data-ttu-id="4ec02-446">Surface メッシュでの粗さを滑らかにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-446">It is possible to smooth out roughness in a surface mesh.</span></span> <span data-ttu-id="4ec02-447">ただし、これにより、対応する実際のサーフェイスから離れた場所にサーフェイスがプッシュされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-447">However, this may push the surface further away from the corresponding real-world surface.</span></span> <span data-ttu-id="4ec02-448">近接性を維持することは、正確なホログラムオクルージョンを生成し、ユーザーが holographic サーフェイスとの正確で予測可能な相互作用を実現できるようにするために重要です。</span><span class="sxs-lookup"><span data-stu-id="4ec02-448">Maintaining a close correspondence is important to produce accurate hologram occlusion, and to enable users to achieve precise and predictable interactions with holographic surfaces.</span></span>
   * <span data-ttu-id="4ec02-449">コスメティックの変更のみが必要な場合は、頂点の位置を変更せずに頂点の法線を滑らかにするだけで十分な場合があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-449">If only a cosmetic change is required, it may be sufficient to smooth vertex normals without changing vertex positions.</span></span>

* <span data-ttu-id="4ec02-450">**平面の検索**</span><span class="sxs-lookup"><span data-stu-id="4ec02-450">**Plane finding**</span></span>
   * <span data-ttu-id="4ec02-451">アプリケーションでは、空間マッピングによって提供されるサーフェイスに対して実行する必要のあるさまざまな形式の分析があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-451">There are many forms of analysis that an application may wish to perform on the surfaces provided by spatial mapping.</span></span>
   * <span data-ttu-id="4ec02-452">単純な例の1つは、"平面検索" です。サーフェイスの境界領域、主に平面領域を識別します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-452">One simple example is 'plane finding'; identifying bounded, mostly-planar regions of surfaces.</span></span>
   * <span data-ttu-id="4ec02-453">平面領域は、アプリケーションによって holographic コンテンツが自動的に配置される holographic のワークサーフェスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-453">Planar regions can be used as holographic work-surfaces, regions where holographic content can be automatically placed by the application.</span></span>
   * <span data-ttu-id="4ec02-454">平面領域では、ユーザーインターフェイスを制限して、ユーザーがニーズに最も合ったサーフェイスと対話できるようにします。</span><span class="sxs-lookup"><span data-stu-id="4ec02-454">Planar regions can constrain the user interface, to guide users to interact with the surfaces that best suit their needs.</span></span>
   * <span data-ttu-id="4ec02-455">平面領域は、LCD 画面、テーブル、ホワイトボードなどの機能オブジェクトに対応する holographic のために、実際の世界のように使用できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-455">Planar regions can be used as in the real world, for holographic counterparts to functional objects such as LCD screens, tables or whiteboards.</span></span>
   * <span data-ttu-id="4ec02-456">平面領域では、再生領域を定義して、videogame レベルの基礎を形成できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-456">Planar regions can define play areas, forming the basis of videogame levels.</span></span>
   * <span data-ttu-id="4ec02-457">平面領域を使用すると、仮想エージェントは、実際の人間が見ている可能性のあるフロアの領域を特定することで、実際の世界を移動できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-457">Planar regions can aid virtual agents to navigate the real world, by identifying the areas of floor that real people are likely to walk on.</span></span>

## <a name="prototyping-and-debugging"></a><span data-ttu-id="4ec02-458">プロトタイプとデバッグ</span><span class="sxs-lookup"><span data-stu-id="4ec02-458">Prototyping and debugging</span></span>

### <a name="useful-tools"></a><span data-ttu-id="4ec02-459">便利なツール</span><span class="sxs-lookup"><span data-stu-id="4ec02-459">Useful tools</span></span>
* <span data-ttu-id="4ec02-460">[Hololens エミュレーター](using-the-hololens-emulator.md)は、物理的な hololens にアクセスせずに空間マッピングを使用するアプリケーションを開発するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-460">The [HoloLens emulator](using-the-hololens-emulator.md) can be used to develop applications using spatial mapping without access to a physical HoloLens.</span></span> <span data-ttu-id="4ec02-461">これにより、hololens でのライブセッションをリアルな環境でシミュレートし、アプリケーションが通常使用するすべてのデータ (HoloLens モーション、空間座標系、空間マッピングメッシュなど) を使用することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-461">It allows you to simulate a live session on a HoloLens in a realistic environment, with all of the data your application would normally consume, including HoloLens motion, spatial coordinate systems and spatial mapping meshes.</span></span> <span data-ttu-id="4ec02-462">これを使用すると、信頼性のある反復可能な入力を提供できます。これは、問題をデバッグし、コードの変更を評価するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-462">This can be used to provide reliable, repeatable input, which can be useful for debugging problems and evaluating changes to your code.</span></span>
* <span data-ttu-id="4ec02-463">シナリオを再現するには、ライブ HoloLens からネットワーク経由で空間マッピングデータをキャプチャし、それをディスクに保存して、後続のデバッグセッションで再利用します。</span><span class="sxs-lookup"><span data-stu-id="4ec02-463">To reproduce a scenarios, capture spatial mapping data over the network from a live HoloLens, then save it to disk and reuse it in subsequent debugging sessions.</span></span>
* <span data-ttu-id="4ec02-464">[Windows デバイスポータルの3d ビュー](using-the-windows-device-portal.md#3d-view)では、空間マッピングシステムを介して現在使用可能なすべての空間サーフェスを確認することができます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-464">The [Windows device portal 3D view](using-the-windows-device-portal.md#3d-view) provides a way to see all of the spatial surfaces currently available via the spatial mapping system.</span></span> <span data-ttu-id="4ec02-465">これにより、アプリケーション内の空間サーフェスを比較する基準が提供されます。たとえば、不足しているか、間違った場所に表示されている空間サーフェスがあるかどうかを簡単に確認できます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-465">This provides a basis of comparison for the spatial surfaces inside your application; for example you can easily tell if any spatial surfaces are missing or are being displayed in the wrong place.</span></span>

### <a name="general-prototyping-guidance"></a><span data-ttu-id="4ec02-466">プロトタイプの一般的なガイダンス</span><span class="sxs-lookup"><span data-stu-id="4ec02-466">General prototyping guidance</span></span>
* <span data-ttu-id="4ec02-467">空間マッピングデータの[エラー](spatial-mapping.md#what-influences-spatial-mapping-quality)はユーザーのエクスペリエンスに大きな影響を与える可能性があるため、さまざまな環境でアプリケーションをテストすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4ec02-467">Because [errors](spatial-mapping.md#what-influences-spatial-mapping-quality) in the spatial mapping data may strongly affect your user's experience, we recommend that you test your application in a wide variety of environments.</span></span>
* <span data-ttu-id="4ec02-468">たとえば、机で同じ場所に常にテストするという習慣ではトラップされません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-468">Don't get trapped in the habit of always testing in the same location, for example at your desk.</span></span> <span data-ttu-id="4ec02-469">さまざまな位置、形状、サイズ、およびマテリアルのさまざまなサーフェイスでテストを行うようにしてください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-469">Make sure to test on various surfaces of different positions, shapes, sizes and materials.</span></span>
* <span data-ttu-id="4ec02-470">同様に、統合または記録されたデータはデバッグに役立ちますが、同じ少数のテストケースには依存しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="4ec02-470">Similarly, while synthetic or recorded data can be useful for debugging, don't become too reliant upon the same few test cases.</span></span> <span data-ttu-id="4ec02-471">これにより、より多様なテストが以前に検出された重要な問題を見つけることが遅れる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-471">This may delay finding important issues that more varied testing would have caught earlier.</span></span>
* <span data-ttu-id="4ec02-472">実際のユーザー (および理想的には coached ではありません) でテストを実行することをお勧めします。これは、ユーザーが HoloLens またはアプリケーションをまったく同じ方法で使用しない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="4ec02-472">It is a good idea to perform testing with real (and ideally un-coached) users, because they may not use the HoloLens or your application in exactly the same way that you do.</span></span> <span data-ttu-id="4ec02-473">実際には、異なるているユーザーの行動、知識、および前提条件はどのようになるかを驚かれるかもしれません。</span><span class="sxs-lookup"><span data-stu-id="4ec02-473">In fact, it may surprise you how divergent people's behavior, knowledge and assumptions can be!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="4ec02-474">トラブルシューティング</span><span class="sxs-lookup"><span data-stu-id="4ec02-474">Troubleshooting</span></span>
* <span data-ttu-id="4ec02-475">サーフェスメッシュを適切に配置するためには、各 SurfaceObserver オブジェクトをアクティブにしてから、メッシュが構築されるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-475">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObserver to have its mesh constructed.</span></span> <span data-ttu-id="4ec02-476">そうしないと、メッシュはスペースに表示されますが、回転角度は変わってきます。</span><span class="sxs-lookup"><span data-stu-id="4ec02-476">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="4ec02-477">SurfaceObserver と通信するスクリプトを実行するオブジェクトは、オリジンに設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-477">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="4ec02-478">そうしないと、メッシュを構築するために作成して SurfaceObserver に送信するすべてのゲームオブジェクトが、親 Game オブジェクトのオフセットと同じオフセットを持つことになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-478">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="4ec02-479">これにより、メッシュがいくつかのメーターを表示して、何が起こっているかを簡単にデバッグできるようになります。</span><span class="sxs-lookup"><span data-stu-id="4ec02-479">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="4ec02-480">参照</span><span class="sxs-lookup"><span data-stu-id="4ec02-480">See also</span></span>
* [<span data-ttu-id="4ec02-481">座標系</span><span class="sxs-lookup"><span data-stu-id="4ec02-481">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="4ec02-482">DirectX の空間マッピング</span><span class="sxs-lookup"><span data-stu-id="4ec02-482">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="4ec02-483">Unity の空間マッピング</span><span class="sxs-lookup"><span data-stu-id="4ec02-483">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="4ec02-484">シーンの理解</span><span class="sxs-lookup"><span data-stu-id="4ec02-484">Scene Understanding</span></span>](scene-understanding.md)
* [<span data-ttu-id="4ec02-485">部屋のスキャンの可視化</span><span class="sxs-lookup"><span data-stu-id="4ec02-485">Room scan visualization</span></span>](room-scan-visualization.md)
* [<span data-ttu-id="4ec02-486">立体音響の設計</span><span class="sxs-lookup"><span data-stu-id="4ec02-486">Spatial sound design</span></span>](spatial-sound-design.md)
* [<span data-ttu-id="4ec02-487">ケース スタディ - Mixed Reality で穴から覗く</span><span class="sxs-lookup"><span data-stu-id="4ec02-487">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
