---
title: ホログラムの安定性
description: HoloLens はホログラムを自動的に安定させますが、開発者はさらにホログラムの安定性を向上させるために実行できる手順があります。
author: thetuvix
ms.author: alexturn
ms.date: 03/21/2018
ms.topic: article
keywords: ホログラム、安定性、hololens
ms.openlocfilehash: ad48d057ee55d4d0d9ae3080d8030a481aef130f
ms.sourcegitcommit: 0a1af2224c9cbb34591b6cb01159b60b37dfff0c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79375779"
---
# <a name="hologram-stability"></a><span data-ttu-id="6f9c0-104">ホログラムの安定性</span><span class="sxs-lookup"><span data-stu-id="6f9c0-104">Hologram stability</span></span>

<span data-ttu-id="6f9c0-105">安定したホログラムを実現するために、HoloLens にはイメージ安定化パイプラインが組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-105">To achieve stable holograms, HoloLens has a built-in image stabilization pipeline.</span></span> <span data-ttu-id="6f9c0-106">安定化パイプラインはバックグラウンドで自動的に動作するため、有効にするために余分な手順は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-106">The stabilization pipeline works automatically in the background, so there are no extra steps required to enable it.</span></span> <span data-ttu-id="6f9c0-107">ただし、開発者は、ホログラムの安定性を向上させる手法を実行し、安定性を低下させるシナリオを回避する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-107">However, developers should exercise techniques that improve hologram stability and avoid scenarios that reduce stability.</span></span>

## <a name="hologram-quality-terminology"></a><span data-ttu-id="6f9c0-108">ホログラムの品質に関する用語</span><span class="sxs-lookup"><span data-stu-id="6f9c0-108">Hologram quality terminology</span></span>

<span data-ttu-id="6f9c0-109">ホログラムの品質は、優れた環境と優れたアプリ開発の結果となります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-109">The quality of holograms is a result of good environment and good app development.</span></span> <span data-ttu-id="6f9c0-110">HoloLens が周囲を追跡できる環境で、1秒あたりに定数60のフレームをヒットしたアプリは、ホログラムと一致する座標系が同期されていることを確認します。ユーザーの観点からは、静止しているホログラムは、環境に対して相対的には移動しません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-110">Apps that hit a constant 60 frames-per-second in an environment where HoloLens can track the surroundings will ensure the hologram and the matching coordinate system are in sync. From a user's perspective, holograms that are meant to be stationary will not move relative to the environment.</span></span>

<span data-ttu-id="6f9c0-111">環境で問題が発生した場合、レンダリング速度が一貫していない場合、またはその他のアプリの問題が発生した場合は、次の用語が問題を特定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-111">When environment issues, inconsistent or low rendering rates, or other app problems show up, the following terminology is helpful in identifying the problem.</span></span>
* <span data-ttu-id="6f9c0-112">**精度.**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-112">**Accuracy.**</span></span> <span data-ttu-id="6f9c0-113">ホログラムが世界中にロックされ、現実世界に配置されると、ユーザーの動きや小規模な環境の変化に関係なく、周囲の環境を基準とした場所に配置されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-113">Once the hologram is world-locked and placed in the real world, it should stay where it was placed, relative to the surrounding environment, independent of user motion or small and sparse environment changes.</span></span> <span data-ttu-id="6f9c0-114">後でホログラムが予期しない場所にある場合は、*精度*の問題になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-114">If a hologram later appears in an unexpected location, it is an *accuracy* problem.</span></span> <span data-ttu-id="6f9c0-115">このようなシナリオは、2つの異なるルームが同一である場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-115">Such scenarios can happen if two distinct rooms look identical.</span></span>
* <span data-ttu-id="6f9c0-116">**ずれ.**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-116">**Jitter.**</span></span> <span data-ttu-id="6f9c0-117">ユーザーはこれをホログラムの高周波数のぶれとして観察します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-117">Users observe this as high frequency shaking of a hologram.</span></span> <span data-ttu-id="6f9c0-118">これは、環境の追跡が低下した場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-118">This can happen when tracking of the environment degrades.</span></span> <span data-ttu-id="6f9c0-119">ユーザーの場合、ソリューションは[センサーチューニング](sensor-tuning.md)を実行しています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-119">For users, the solution is running [sensor tuning](sensor-tuning.md).</span></span>
* <span data-ttu-id="6f9c0-120">**Judder.**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-120">**Judder.**</span></span> <span data-ttu-id="6f9c0-121">レンダリング周波数が低いと、ホログラムの動きとダブルイメージが不均一になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-121">Low rendering frequencies result in uneven motion and double images of holograms.</span></span> <span data-ttu-id="6f9c0-122">これは、モーションを持つホログラムで特に顕著です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-122">This is especially noticeable in holograms with motion.</span></span> <span data-ttu-id="6f9c0-123">開発者は、 [60 FPS の定数](hologram-stability.md#frame-rate)を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-123">Developers need to maintain a [constant 60 FPS](hologram-stability.md#frame-rate).</span></span>
* <span data-ttu-id="6f9c0-124">**誤差.**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-124">**Drift.**</span></span> <span data-ttu-id="6f9c0-125">これは、最初に配置された場所から離れるように、ホログラムとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-125">Users see this as a hologram appears to move away from where it was originally placed.</span></span> <span data-ttu-id="6f9c0-126">これは、特に、完全にマップされていない環境の一部で、ホログラムが[空間アンカー](spatial-anchors.md)から遠く離れた場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-126">This happens when holograms are placed far away from [spatial anchors](spatial-anchors.md), particularly in parts of the environment that have not been fully mapped.</span></span> <span data-ttu-id="6f9c0-127">空間アンカーの近くにホログラムを作成すると、誤差の可能性が低くなります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-127">Creating holograms close to spatial anchors lowers the likelihood of drift.</span></span>
* <span data-ttu-id="6f9c0-128">**Jumpiness.**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-128">**Jumpiness.**</span></span> <span data-ttu-id="6f9c0-129">ホログラムが位置をときどき "ポップ" または "ジャンプ" するとき。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-129">When a hologram "pops" or "jumps" away from its location occasionally.</span></span> <span data-ttu-id="6f9c0-130">これは、追跡によって、環境の最新の理解に一致するようにホログラムが調整されると発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-130">This can occur as tracking adjusts holograms to match updated understanding of your environment.</span></span>
* <span data-ttu-id="6f9c0-131">**スイム.**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-131">**Swim.**</span></span> <span data-ttu-id="6f9c0-132">ユーザーの頭の動きに対応する、ホログラムが sway に表示されるとき。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-132">When a hologram appears to sway corresponding to the motion of the user's head.</span></span> <span data-ttu-id="6f9c0-133">このエラーは、アプリケーションが[reprojection](hologram-stability.md#reprojection)を完全に実装していない場合、および HoloLens が現在のユーザーに対して[調整](calibration.md)されていない場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-133">This occurs when the application has not fully implemented [reprojection](hologram-stability.md#reprojection), and if the HoloLens is not [calibrated](calibration.md) for the current user.</span></span> <span data-ttu-id="6f9c0-134">ユーザーは[調整](calibration.md)アプリケーションを再実行して、この問題を修正できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-134">The user can rerun the [calibration](calibration.md) application to fix this.</span></span> <span data-ttu-id="6f9c0-135">開発者は、安定化平面を更新して安定性をさらに向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-135">Developers can update the stabilization plane to further enhance stability.</span></span>
* <span data-ttu-id="6f9c0-136">**色の分離。**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-136">**Color separation.**</span></span> <span data-ttu-id="6f9c0-137">HoloLens のディスプレイはカラーの連続した表示であり、フラッシュカラーチャンネルは 60Hz (個々の色フィールドは 240Hz) で点滅します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-137">The displays in HoloLens are a color sequential display, which flash color channels of red-green-blue-green at 60Hz (individual color fields are shown at 240Hz).</span></span> <span data-ttu-id="6f9c0-138">ユーザーが目を通して移動するホログラムを追跡するたびに、そのホログラムの先頭および末尾のエッジは、構成色が異なるため、レインボー効果が生成されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-138">Whenever a user tracks a moving hologram with his or her eyes, that hologram's leading and trailing edges separate in their constituent colors, producing a rainbow effect.</span></span> <span data-ttu-id="6f9c0-139">分離の度合いは、ホログラムの速度に依存します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-139">The degree of separation is dependent upon the speed of the hologram.</span></span> <span data-ttu-id="6f9c0-140">場合によっては、固定されたホログラムを見ながら1頭を移動すると、レインボー効果が生じることもあります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-140">In some rarer cases, moving ones head rapidly while looking at a stationary hologram can also result in a rainbow effect.</span></span> <span data-ttu-id="6f9c0-141">これは、 *[色の分離](hologram-stability.md#color-separation)* と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-141">This is called *[color separation](hologram-stability.md#color-separation)*.</span></span>

## <a name="frame-rate"></a><span data-ttu-id="6f9c0-142">フレーム率</span><span class="sxs-lookup"><span data-stu-id="6f9c0-142">Frame rate</span></span>

<span data-ttu-id="6f9c0-143">フレームレートは、ホログラムの安定性の最初の柱です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-143">Frame rate is the first pillar of hologram stability.</span></span> <span data-ttu-id="6f9c0-144">ホログラムが世界中で安定して表示されるようにするには、ユーザーに表示される各イメージに、正しい位置にホログラムが描画されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-144">For holograms to appear stable in the world, each image presented to the user must have the holograms drawn in the correct spot.</span></span> <span data-ttu-id="6f9c0-145">では、HoloLens の更新時に240に1秒間隔で表示され、新たにレンダリングされたイメージごとに4つの色フィールドが表示されます。これにより、60 FPS (1 秒あたりのフレーム数) のユーザーエクスペリエンスが得られます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-145">The displays on HoloLens refresh 240 times a second, showing four separate color fields for each newly rendered image, resulting in a user experience of 60 FPS (frames per second).</span></span> <span data-ttu-id="6f9c0-146">アプリケーション開発者は、可能な限り最良の方法を提供するために、60 FPS を維持する必要があります。これにより、オペレーティングシステムに対して16ミリ秒ごとに新しいイメージが一貫して提供されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-146">To provide the best experience possible, application developers must maintain 60 FPS, which translates to consistently providing a new image to the operating system every 16 milliseconds.</span></span>

<span data-ttu-id="6f9c0-147">**60 FPS**ホログラムを実際の世界に座っているように描画するには、ユーザーの位置からイメージをレンダリングする必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-147">**60 FPS** To draw holograms to look like they're sitting in the real world, HoloLens needs to render images from the user's position.</span></span> <span data-ttu-id="6f9c0-148">イメージのレンダリングには時間がかかるため、ディスプレイに画像が表示されたときのユーザーの頭の位置が HoloLens によって予測されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-148">Since image rendering takes time, HoloLens predicts where a user's head will be when the images are shown in the displays.</span></span> <span data-ttu-id="6f9c0-149">この予測アルゴリズムは近似値です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-149">This prediction algorithm is an approximation.</span></span> <span data-ttu-id="6f9c0-150">HoloLens には、レンダリングされたイメージを調整して、予測されるヘッド位置と実際のヘッド位置との違いを考慮するハードウェアがあります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-150">HoloLens has hardware that adjusts the rendered image to account for the discrepancy between the predicted head position and the actual head position.</span></span> <span data-ttu-id="6f9c0-151">これにより、ユーザーに表示されるイメージは、正しい位置から表示されているかのように見え、ホログラムが安定しているように見えます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-151">This makes the image the user sees appear as if it was rendered from the correct location, and holograms feel stable.</span></span> <span data-ttu-id="6f9c0-152">イメージの更新は、小さな変更によって最適に機能します。また、視差のようにレンダリングされたイメージ内の特定の項目を完全に修正することはできません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-152">The image updates work best with small changes, and it can't completely fix certain things in the rendered image like motion-parallax.</span></span>

<span data-ttu-id="6f9c0-153">60 FPS でレンダリングすることにより、安定したホログラムの作成に役立つ3つの作業を行います。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-153">By rendering at 60 FPS, you are doing three things to help make stable holograms:</span></span>
1. <span data-ttu-id="6f9c0-154">イメージのレンダリングと、そのイメージがユーザーに表示されるまでの全体的な待機時間を最小限に抑えます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-154">Minimizing the overall latency between rendering an image and that image being seen by the user.</span></span> <span data-ttu-id="6f9c0-155">ロックステップで実行されるゲーム スレッドとレンダリング スレッドがあるエンジンでは、30 FPS で実行すると、待機時間がさらに 33.3 ミリ秒長くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-155">In an engine with a game thread and a render thread running in lockstep, running at 30FPS can add 33.3ms of extra latency.</span></span> <span data-ttu-id="6f9c0-156">待機時間を短縮することで予測エラーが減少し、ホログラムの安定性が向上します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-156">By reducing latency, this decreases prediction error, and increases hologram stability.</span></span>
2. <span data-ttu-id="6f9c0-157">これにより、すべてのイメージがユーザーの目に到達するまでの待機時間が一貫しています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-157">Making it so every image reaching the user's eyes have a consistent amount of latency.</span></span> <span data-ttu-id="6f9c0-158">30 fps でレンダリングした場合でも、画像は 60 FPS で表示されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-158">If you render at 30fps, the display still displays images at 60 FPS.</span></span> <span data-ttu-id="6f9c0-159">これは、同じイメージが1行に2回表示されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-159">This means the same image will be displayed twice in a row.</span></span> <span data-ttu-id="6f9c0-160">2番目のフレームは、最初のフレームよりも 16.6 ms の待機時間が長くなり、より顕著なエラーを修正する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-160">The second frame will have 16.6ms more latency than the first frame and will have to correct a more pronounced amount of error.</span></span> <span data-ttu-id="6f9c0-161">このようなエラーの大きさが不整合になると、60hz judder が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-161">This inconsistency in error magnitude can cause unwanted 60hz judder.</span></span>
3. <span data-ttu-id="6f9c0-162">一様ではない動作と二重画像によって特徴付けられるジャダーの出現を減らします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-162">Reducing the appearance of judder, which is characterized by uneven motion and double images.</span></span> <span data-ttu-id="6f9c0-163">高速なホログラムの動きと低いレンダリング レートは、顕著なジャダーに関連しています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-163">Faster hologram motion and lower render rates are associated with more pronounced judder.</span></span> <span data-ttu-id="6f9c0-164">そのため、常に 60 FPS を維持することによって、特定の可動ホログラムの judder を回避することができます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-164">Therefore, striving to maintain 60 FPS at all times will help avoid judder for a given moving hologram.</span></span>

<span data-ttu-id="6f9c0-165">**フレームレートの一貫性**フレームレートの一貫性は、1秒あたりの高フレーム数と同様に重要です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-165">**Frame-rate consistency** Frame rate consistency is as important as a high frames-per-second.</span></span> <span data-ttu-id="6f9c0-166">場合によっては、コンテンツが豊富なアプリケーションでフレームが破棄されることはありません。また、HoloLens は、不定期に発生した障害から復旧するための高度なアルゴリズムを実装します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-166">Occasionally dropped frames are inevitable for any content-rich application, and the HoloLens implements some sophisticated algorithms to recover from occasional glitches.</span></span> <span data-ttu-id="6f9c0-167">ただし、絶えず変動するフレームレートは、ユーザーにとって、より低いフレームレートで一貫して実行するよりもはるかに顕著です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-167">However, a constantly fluctuating framerate is a lot more noticeable to a user than running consistently at lower frame rates.</span></span> <span data-ttu-id="6f9c0-168">たとえば、5つのフレーム (これらの5つのフレームの実行中は 60 FPS) に対してスムーズにレンダリングし、次の10フレーム (10 フレームの間は 30 FPS) に対して他のフレームをすべてドロップするアプリケーションは、一貫していないアプリケーションよりも不安定であると思われます。30 FPS でレンダリングします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-168">For example, an application that renders smoothly for 5 frames (60 FPS for the duration of these 5 frames) and then drops every other frame for the next 10 frames (30 FPS for the duration of these 10 frames) will appear more unstable than an application that consistently renders at 30 FPS.</span></span>

<span data-ttu-id="6f9c0-169">関連する注意事項として、オペレーティングシステムは、混合の現実の[キャプチャ](mixed-reality-capture.md)が実行されている場合に、アプリケーションを 30 FPS に調整します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-169">On a related note, the operating system will throttle applications down to 30 FPS when [mixed reality capture](mixed-reality-capture.md) is running.</span></span>

<span data-ttu-id="6f9c0-170">**パフォーマンス分析**アプリケーションのフレームレートのベンチマークに使用できるツールには、次のようなものがあります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-170">**Performance analysis** There are a variety of tools that can be used to benchmark your application frame rate, such as:</span></span>
* <span data-ttu-id="6f9c0-171">GPUView</span><span class="sxs-lookup"><span data-stu-id="6f9c0-171">GPUView</span></span>
* <span data-ttu-id="6f9c0-172">Visual Studio Graphics Debugger</span><span class="sxs-lookup"><span data-stu-id="6f9c0-172">Visual Studio Graphics Debugger</span></span>
* <span data-ttu-id="6f9c0-173">Unity などの3D エンジンに組み込まれたプロファイラー</span><span class="sxs-lookup"><span data-stu-id="6f9c0-173">Profilers built into 3D engines such as Unity</span></span>

## <a name="hologram-render-distances"></a><span data-ttu-id="6f9c0-174">ホログラムのレンダリング距離</span><span class="sxs-lookup"><span data-stu-id="6f9c0-174">Hologram render distances</span></span>

>[!VIDEO https://www.youtube.com/embed/-606oZKLa_s]

<span data-ttu-id="6f9c0-175">人間のビジュアルシステムでは、オブジェクトを固定し、オブジェクトに焦点を当てたときに、複数の距離に依存する信号を統合します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-175">The human visual system integrates multiple distance-dependent signals when it fixates and focuses on an object.</span></span>
* <span data-ttu-id="6f9c0-176">[宿泊施設](https://en.wikipedia.org/wiki/Accommodation_%28eye%29)-個々の視点の焦点。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-176">[Accommodation](https://en.wikipedia.org/wiki/Accommodation_%28eye%29) - The focus of an individual eye.</span></span>
* <span data-ttu-id="6f9c0-177">[収束](https://en.wikipedia.org/wiki/Convergence_(eye))-オブジェクトの中心に向かって、または外側に移動する2つの目。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-177">[Convergence](https://en.wikipedia.org/wiki/Convergence_(eye)) - Two eyes moving inward or outward to center on an object.</span></span>
* <span data-ttu-id="6f9c0-178">[付い双眼鏡](https://en.wikipedia.org/wiki/Stereopsis)格差は、オブジェクトの距離に依存している、左側と右目の画像との間の距離を示します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-178">[Binocular vision](https://en.wikipedia.org/wiki/Stereopsis) - Disparities between the left- and right-eye images that are dependent on an object's distance away from your fixation point.</span></span>
* <span data-ttu-id="6f9c0-179">網掛け、相対角度のサイズ、およびその他の monocular (単一目) のキュー。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-179">Shading, relative angular size, and other monocular (single eye) cues.</span></span>

<span data-ttu-id="6f9c0-180">収束と設備は、異なる距離でオブジェクトを認識するように目が変化する方法に関連する特別な網膜の手掛かりであるため、一意です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-180">Convergence and accommodation are unique because they are extra-retinal cues related to how the eyes change to perceive objects at different distances.</span></span> <span data-ttu-id="6f9c0-181">自然な表示では、収束と設備がリンクされています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-181">In natural viewing, convergence and accommodation are linked.</span></span> <span data-ttu-id="6f9c0-182">目が近くに表示されている場合 (例: 鼻)、目は近くにあり、近いポイントに対応しています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-182">When the eyes view something near (e.g. your nose), the eyes cross and accommodate to a near point.</span></span> <span data-ttu-id="6f9c0-183">目が無限に表示されると、目は並列になり、目は無限大になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-183">When the eyes view something at infinity, the eyes become parallel and the eye accommodates to infinity.</span></span> <span data-ttu-id="6f9c0-184">Hololens のディスプレイは、ユーザーから約2.0 分離れている光学式の距離で固定されているため、HoloLens を装着したユーザーは常に 2.0 m に対応して明確なイメージを維持します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-184">Users wearing HoloLens will always accommodate to 2.0m to maintain a clear image because the HoloLens displays are fixed at an optical distance approximately 2.0m away from the user.</span></span> <span data-ttu-id="6f9c0-185">アプリ開発者は、さまざまな深度でコンテンツとホログラムを配置することで、ユーザーの目がどのようになるかを制御します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-185">App developers control where users' eyes converge by placing content and holograms at various depths.</span></span> <span data-ttu-id="6f9c0-186">ユーザーがさまざまな距離に対応して収束すると、2つのキュー間の自然なリンクが失われます。これにより、特に競合の大きさが大きい場合に、visual 不快感や疲労が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-186">When users accommodate and converge to different distances, the natural link between the two cues are broken, which can lead to visual discomfort or fatigue, especially when the magnitude of the conflict is large.</span></span> <span data-ttu-id="6f9c0-187">Vergence の競合からの不快感は、ユーザーが可能な限り 2.0 m に近いコンテンツを保持することによって回避または最小化できます (つまり、可能な限り 2.0 m 付近に関心のある領域を多数のシーンに配置します)。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-187">Discomfort from the vergence-accommodation conflict can be avoided or minimized by keeping content that users converge to as close to 2.0m as possible (i.e. in a scene with lots of depth place the areas of interest near 2.0m, when possible).</span></span> <span data-ttu-id="6f9c0-188">コンテンツを 2.0 m の近くに配置することはできませんが、ユーザーの距離が異なる場合は、vergence の競合の不快感が最大になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-188">When content cannot be placed near 2.0m, discomfort from the vergence-accommodation conflict is greatest when user’s gaze back and forth between different distances.</span></span> <span data-ttu-id="6f9c0-189">言い換えると、50 cm の距離で静止したホログラムを見る方が、50 cm の距離にあるホログラムが時間の経過と共に近づいたり離れたりするのを見るよりもはるかに快適です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-189">In other words, it is much more comfortable to look at a stationary hologram that stays 50cm away than to look at a hologram 50cm away that moves toward and away from you over time.</span></span>

<span data-ttu-id="6f9c0-190">2つのディスプレイがこの距離で完全に重複するように設計されているため、2.0 m にコンテンツを配置することも便利です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-190">Placing content at 2.0m is also advantageous because the two displays are designed to fully overlap at this distance.</span></span> <span data-ttu-id="6f9c0-191">この平面から離れた画像の場合、holographic フレームの横から移動すると、他の画面に表示されている間、1つのディスプレイから見えなくなります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-191">For images placed off this plane, as they move off the side of the holographic frame they will disappear from one display while still being visible on the other.</span></span> <span data-ttu-id="6f9c0-192">この付い双眼鏡 rivalry、ホログラムの深さの知覚に悪影響を及ぼす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-192">This binocular rivalry can be disruptive to the depth perception of the hologram.</span></span>

<span data-ttu-id="6f9c0-193">**ユーザーからホログラムを配置する位置までの最適な距離**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-193">**Optimal distance for placing holograms from the user**</span></span>

![ユーザーにホログラムを配置するための最適な距離](images/distanceguiderendering-750px.png)

<span data-ttu-id="6f9c0-195">**クリッププレーン**最大の快適さを提供するには、1m バイトからのコンテンツの facm でのレンダリング距離をクリッピングすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-195">**Clip Planes** For maximum comfort, we recommend clipping render distance at 85cm with fadeout of content starting at 1m.</span></span> <span data-ttu-id="6f9c0-196">ホログラムとユーザーの両方が静止しているアプリケーションでは、ホログラムを50cm の近くに表示できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-196">In applications where holograms and users are both stationary, holograms can be viewed comfortably as near as 50cm.</span></span> <span data-ttu-id="6f9c0-197">このような場合、アプリケーションでは、クリップ平面を30cm 以下にし、フェードアウトをクリッププレーンから少なくとも10cm 離れた位置に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-197">In those cases, applications should place a clip plane no closer than 30cm and fade out should start at least 10cm away from the clip plane.</span></span> <span data-ttu-id="6f9c0-198">コンテンツが85cm より近い場合は常に、ユーザーがホログラムから近い場所に移動したり、ホログラムから遠くに移動したりしないようにすることが重要です。また、このような状況では、不快感の原因となる可能性が高いため、vergence の競合。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-198">Whenever content is closer than 85cm, it is important to ensure that users do not frequently move closer or farther from holograms or that holograms do not frequently move closer to or farther from the user as these situations are most likely to cause discomfort from the vergence-accommodation conflict.</span></span> <span data-ttu-id="6f9c0-199">コンテンツは、ユーザーからの85cm より近くのやり取りの必要性を最小限に抑えるように設計する必要がありますが、85cm より近い場所にコンテンツをレンダリングする必要がある場合は、開発者にとっての経験則として、ユーザーまたはホログラムが25% 以上の時間で移動しないシナリオを設計します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-199">Content should be designed to minimize the need for interaction closer than 85cm from the user, but when content must be rendered closer than 85cm, a good rule of thumb for developers is to design scenarios where users and/or holograms do not move in depth more than 25% of the time.</span></span>

<span data-ttu-id="6f9c0-200">**ベストプラクティス**ホログラムを2m に配置できず、収束と設備の間の競合を回避できない場合、ホログラムの配置に最適なゾーンは 1.25 m と5分の間になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-200">**Best practices** When holograms cannot be placed at 2m and conflicts between convergence and accommodation cannot be avoided, the optimal zone for hologram placement is between 1.25m and 5m.</span></span> <span data-ttu-id="6f9c0-201">どのような場合でも、デザイナーは、ユーザーが 1 + m を操作できるようにコンテンツを構成する必要があります (たとえば、コンテンツサイズと既定の配置パラメーターを調整します)。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-201">In every case, designers should structure content to encourage users to interact 1+ m away (e.g. adjust content size and default placement parameters).</span></span>

## <a name="reprojection"></a><span data-ttu-id="6f9c0-202">再プロジェクション</span><span class="sxs-lookup"><span data-stu-id="6f9c0-202">Reprojection</span></span>
<span data-ttu-id="6f9c0-203">HoloLens は、reprojection と呼ばれる高度なハードウェア支援型の holographic 安定化手法を実行します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-203">HoloLens performs a sophisticated hardware-assisted holographic stabilization technique known as reprojection.</span></span> <span data-ttu-id="6f9c0-204">シーンがアニメーション化され、ユーザーがその頭を動かしたときに、これによって、視点 (CameraPose) の動きと変化が考慮されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-204">This takes into account motion and change of the point of view (CameraPose) as the scene animates and the user moves their head.</span></span>  <span data-ttu-id="6f9c0-205">アプリケーションでは、reprojection を最大限に活用するために、特定のアクションを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-205">Applications need to take specific actions to best use reprojection.</span></span>


<span data-ttu-id="6f9c0-206">再プロジェクションには主に4種類あります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-206">There are four main types of reprojection</span></span>
* <span data-ttu-id="6f9c0-207">**深さの再投影:** これにより、アプリケーションの作業量を最小限に抑えて最適な結果が得られます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-207">**Depth Reprojection:**  This produces the best results with the least amount of effort from the application.</span></span>  <span data-ttu-id="6f9c0-208">レンダリングされたシーンのすべての部分は、ユーザーからの距離に基づいて、個別に安定化されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-208">All parts of the rendered scene are independently stabilized based on their distance from the user.</span></span>  <span data-ttu-id="6f9c0-209">一部のレンダリングアイテムは、詳細な変更がある場所で表示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-209">Some rendering artifacts may be visible where there are sharp changes in depth.</span></span>  <span data-ttu-id="6f9c0-210">このオプションは、HoloLens 2 とイマーシブヘッドセットでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-210">This option is only available on HoloLens 2 and Immersive Headsets.</span></span>
* <span data-ttu-id="6f9c0-211">**平面の再プロジェクション:** これにより、アプリケーションは安定化を厳密に制御できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-211">**Planar Reprojection:**  This allows the application precise control over stabilization.</span></span>  <span data-ttu-id="6f9c0-212">平面はアプリケーションによって設定され、その平面上のすべてのものがシーンの最も安定した部分になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-212">A plane is set by the application and everything on that plane will be the most stable part of the scene.</span></span>  <span data-ttu-id="6f9c0-213">さらに、ホログラムは平面から離れているので、安定性は低くなります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-213">The further a hologram is away from the plane, the less stable it will be.</span></span>  <span data-ttu-id="6f9c0-214">このオプションは、すべての Windows MR プラットフォームで使用できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-214">This option is available on all Windows MR platforms.</span></span>
* <span data-ttu-id="6f9c0-215">**自動平面再プロジェクション:** システムは、深度バッファーの情報を使用して安定化平面を設定します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-215">**Automatic Planar Reprojection:**  The system sets a stabilization plane using information in the depth buffer.</span></span>  <span data-ttu-id="6f9c0-216">このオプションは、HoloLens generation 1 および HoloLens 2 で使用できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-216">This option is available on HoloLens generation 1 and HoloLens 2.</span></span>
* <span data-ttu-id="6f9c0-217">**なし:** アプリケーションが何も実行しない場合は、ユーザーの頭を見つめた方向に2メートルで固定されている安定化平面で平面 Reprojection が使用されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-217">**None:** If the application does nothing, Planar Reprojection is used with the stabilization plane fixed at 2 meters in the direction of the user's head gaze.</span></span>  <span data-ttu-id="6f9c0-218">これにより、通常は下回っの結果が生成されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-218">This will usually produce substandard results.</span></span>

<span data-ttu-id="6f9c0-219">アプリケーションは、さまざまな種類の再プロジェクションを可能にするために、特定のアクションを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-219">Applications need to take specific actions to enable the different types of reprojection</span></span>
* <span data-ttu-id="6f9c0-220">**深さの再投影:** アプリケーションは、描画されたすべてのフレームの深度バッファーをシステムに送信します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-220">**Depth Reprojection:** The application submits their depth buffer to the system for every rendered frame.</span></span>  <span data-ttu-id="6f9c0-221">Unity では、この操作は、[プレーヤーの設定] ウィンドウの [深度バッファーの共有を有効にする] オプションを使用して行います。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-221">On Unity, this is done with the "Enable Depth Buffer Sharing" option in the Player Settings pane.</span></span>  <span data-ttu-id="6f9c0-222">DirectX アプリは CommitDirect3D11DepthBuffer を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-222">DirectX apps call CommitDirect3D11DepthBuffer.</span></span>  <span data-ttu-id="6f9c0-223">アプリケーションで SetFocusPoint を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-223">The application should not call SetFocusPoint.</span></span>
* <span data-ttu-id="6f9c0-224">**平面の再プロジェクション:** すべてのフレームで、アプリケーションは、安定する平面の場所をシステムに伝えます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-224">**Planar Reprojection:** On every frame, applications tell the system the location of a plane to stabilize.</span></span>  <span data-ttu-id="6f9c0-225">Unity アプリケーションは SetFocusPointForFrame を呼び出し、[深度バッファーの共有を有効にする] が無効になっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-225">Unity applications call SetFocusPointForFrame and should have "Enable Depth Buffer Sharing" disabled.</span></span>  <span data-ttu-id="6f9c0-226">DirectX アプリは SetFocusPoint を呼び出し、CommitDirect3D11DepthBuffer を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-226">DirectX apps call SetFocusPoint and should not call CommitDirect3D11DepthBuffer.</span></span>
* <span data-ttu-id="6f9c0-227">**自動平面再プロジェクション:** これを有効にするには、アプリケーションが深さの再投影の場合と同じように、システムに深度バッファーを送信する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-227">**Automatic Planar Reprojection:** To enable this, the application needs to submit their depth buffer to the system as they would for Depth Reprojection.</span></span>  <span data-ttu-id="6f9c0-228">HoloLens 2 では、アプリケーションは、すべてのフレームに対して0のポイント (0) を SetFocusPoint する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-228">On HoloLens 2, the application then needs to SetFocusPoint with a point of 0,0 for every frame.</span></span>  <span data-ttu-id="6f9c0-229">HoloLens のジェネレーション1の場合、アプリケーションは SetFocusPoint を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-229">For HoloLens generation 1, the application should not call SetFocusPoint.</span></span>

### <a name="choosing-reprojection-technique"></a><span data-ttu-id="6f9c0-230">再プロジェクション技法の選択</span><span class="sxs-lookup"><span data-stu-id="6f9c0-230">Choosing Reprojection Technique</span></span>

<span data-ttu-id="6f9c0-231">安定化の種類</span><span class="sxs-lookup"><span data-stu-id="6f9c0-231">Stabilization Type</span></span> |    <span data-ttu-id="6f9c0-232">イマーシブヘッドセット</span><span class="sxs-lookup"><span data-stu-id="6f9c0-232">Immersive Headsets</span></span> |    <span data-ttu-id="6f9c0-233">HoloLens の生成1</span><span class="sxs-lookup"><span data-stu-id="6f9c0-233">HoloLens generation 1</span></span> | <span data-ttu-id="6f9c0-234">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="6f9c0-234">HoloLens 2</span></span>
--- | --- | --- | ---
<span data-ttu-id="6f9c0-235">深さの再投影</span><span class="sxs-lookup"><span data-stu-id="6f9c0-235">Depth Reprojection</span></span> |    <span data-ttu-id="6f9c0-236">推奨</span><span class="sxs-lookup"><span data-stu-id="6f9c0-236">Recommended</span></span> |   <span data-ttu-id="6f9c0-237">N/A</span><span class="sxs-lookup"><span data-stu-id="6f9c0-237">N/A</span></span> |   <span data-ttu-id="6f9c0-238">推奨</span><span class="sxs-lookup"><span data-stu-id="6f9c0-238">Recommended</span></span><br/><br/><span data-ttu-id="6f9c0-239">Unity アプリケーションでは、Unity 2018.4.12 以降または Unity 2019.3 以降を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-239">Unity applications must use Unity 2018.4.12 or later or Unity 2019.3 or later.</span></span> <span data-ttu-id="6f9c0-240">それ以外の場合は、自動平面 Reprojection を使用します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-240">Otherwise use Automatic Planar Reprojection.</span></span>
<span data-ttu-id="6f9c0-241">自動平面再プロジェクション</span><span class="sxs-lookup"><span data-stu-id="6f9c0-241">Automatic Planar Reprojection</span></span> | <span data-ttu-id="6f9c0-242">N/A</span><span class="sxs-lookup"><span data-stu-id="6f9c0-242">N/A</span></span> |   <span data-ttu-id="6f9c0-243">推奨される既定値</span><span class="sxs-lookup"><span data-stu-id="6f9c0-243">Recommended default</span></span> |   <span data-ttu-id="6f9c0-244">深さの再プロジェクションで最適な結果が得られない場合に推奨</span><span class="sxs-lookup"><span data-stu-id="6f9c0-244">Recommended if Depth Reprojection is not giving the best results</span></span><br/><br/><span data-ttu-id="6f9c0-245">Unity アプリケーションは、Unity 2018.4.12 以降または Unity 2019.3 以降を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-245">Unity applications are recommended to use Unity 2018.4.12 or later or Unity 2019.3 or later.</span></span>  <span data-ttu-id="6f9c0-246">以前のバージョンの Unity は、わずかに低下した再プロジェクション結果で動作します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-246">Previous Unity versions will work with slightly degraded reprojection results.</span></span>
<span data-ttu-id="6f9c0-247">平面の再プロジェクション</span><span class="sxs-lookup"><span data-stu-id="6f9c0-247">Planar Reprojection</span></span> |   <span data-ttu-id="6f9c0-248">推奨されません</span><span class="sxs-lookup"><span data-stu-id="6f9c0-248">Not Recommended</span></span> |   <span data-ttu-id="6f9c0-249">自動平面が最適な結果を得られない場合に推奨</span><span class="sxs-lookup"><span data-stu-id="6f9c0-249">Recommended if Automatic Planar is not giving the best results</span></span> |    <span data-ttu-id="6f9c0-250">いずれの深さのオプションでも目的の結果が得られない場合は、を使用します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-250">Use if neither of the depth options give desired results</span></span>    

### <a name="verifying-depth-is-set-correctly"></a><span data-ttu-id="6f9c0-251">深さが正しく設定されていることを確認しています</span><span class="sxs-lookup"><span data-stu-id="6f9c0-251">Verifying Depth is Set Correctly</span></span>
            
<span data-ttu-id="6f9c0-252">Reprojection メソッドが深度バッファーを使用する場合は、深度バッファーの内容がアプリケーションのレンダリングされたシーンを表すことを確認することが重要です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-252">When a reprojection method uses the depth buffer, it is important to verify that the contents of the depth buffer represents the application's rendered scene.</span></span>  <span data-ttu-id="6f9c0-253">さまざまな要因によって問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-253">A number of factors can cause problems.</span></span>  <span data-ttu-id="6f9c0-254">たとえば、ユーザーインターフェイスのオーバーレイをレンダリングするために使用される2番目のカメラがある場合は、実際のビューからすべての深度情報が上書きされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-254">If there is a second camera used to render user interface overlays, for example, it is likely to overwrite all the depth information from the actual view.</span></span>  <span data-ttu-id="6f9c0-255">多くの場合、透明なオブジェクトは深さを設定しません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-255">Transparent objects often don't set depth.</span></span>  <span data-ttu-id="6f9c0-256">一部のテキスト表示では、既定で深さが設定されません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-256">Some text rendering will not set depth by default.</span></span>  <span data-ttu-id="6f9c0-257">描画に表示される異常は、深度がレンダリングされたホログラムと一致しない場合に表示されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-257">There will be visible glitches in the rendering when depth does not match the rendered holograms.</span></span>
            
<span data-ttu-id="6f9c0-258">HoloLens 2 には、奥行があり、設定されていないことを示すビジュアライザーがあります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-258">HoloLens 2 has a visualizer to show where depth is and is not being set.</span></span>  <span data-ttu-id="6f9c0-259">デバイスポータルからこの設定を有効にします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-259">Enable this from Device Portal.</span></span>  <span data-ttu-id="6f9c0-260">[**表示** > の**ホログラムの安定性**] タブで、[**ヘッドセットの深さの視覚エフェクトを表示**する] チェックボックスをオンにします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-260">On the **Views** > **Hologram Stability** tab, select the **Display depth visualization in headset** checkbox.</span></span>  <span data-ttu-id="6f9c0-261">深度が適切に設定されている領域は青色になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-261">Areas that have depth set properly will be blue.</span></span>  <span data-ttu-id="6f9c0-262">深度が設定されていないレンダリングされた項目は赤になり、修正が必要になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-262">Rendered items that do not have depth set will be red and therefore need fixing.</span></span>  <span data-ttu-id="6f9c0-263">詳細の視覚化は、Mixed Reality のキャプチャでは表示されないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-263">Note that the visualization of the depth will not show up in Mixed Reality Capture.</span></span>  <span data-ttu-id="6f9c0-264">デバイスでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-264">It is only visible through the device.</span></span>
            
<span data-ttu-id="6f9c0-265">一部の GPU 表示ツールでは、深度バッファーを視覚化できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-265">Some GPU viewing tools will allow visualization of the depth buffer.</span></span>  <span data-ttu-id="6f9c0-266">アプリケーション開発者は、これらのツールを使用して、深さが適切に設定されていることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-266">Application developers can use these tools to make sure depth is being set properly.</span></span>  <span data-ttu-id="6f9c0-267">アプリケーションのツールのドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-267">Consult the documentation for the application's tools.</span></span>

### <a name="using-planar-reprojection"></a><span data-ttu-id="6f9c0-268">平面の再プロジェクションの使用</span><span class="sxs-lookup"><span data-stu-id="6f9c0-268">Using Planar Reprojection</span></span>
> [!NOTE]
> <span data-ttu-id="6f9c0-269">デスクトップのイマーシブヘッドセットの場合、通常は安定化平面を設定します。これは、アプリの深度バッファーをシステムに提供してピクセル単位の深さベースの再プロジェクションを有効にするよりも、ビジュアルの品質が低下するためです。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-269">For desktop immersive headsets, setting a stabilization plane is usually counter-productive, as it offers less visual quality than providing your app's depth buffer to the system to enable per-pixel depth-based reprojection.</span></span> <span data-ttu-id="6f9c0-270">HoloLens で実行しない限り、通常は安定化平面の設定を避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-270">Unless running on a HoloLens, you should generally avoid setting the stabilization plane.</span></span>

![3D オブジェクトの安定化平面](images/stab-plane-500px.jpg)

<span data-ttu-id="6f9c0-272">デバイスは自動的にこの平面を選択しようとしますが、アプリケーションはシーンのフォーカスポイントを選択することによって、このプロセスを支援する必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-272">The device will automatically attempt to choose this plane, but the application should assist in this process by selecting the focus point in the scene.</span></span> <span data-ttu-id="6f9c0-273">HoloLens で実行されている Unity アプリでは、シーンに基づいて最適なポイントを選択し、それを[SetFocusPoint ()](focus-point-in-unity.md)に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-273">Unity apps running on a HoloLens should choose the best focus point based on your scene and pass this into [SetFocusPoint()](focus-point-in-unity.md).</span></span> <span data-ttu-id="6f9c0-274">DirectX でフォーカスポイントを設定する例は、既定のスピンキューブテンプレートに含まれています。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-274">An example of setting the focus point in DirectX is included in the default spinning cube template.</span></span>

<span data-ttu-id="6f9c0-275">デスクトップ PC に接続されているイマーシブヘッドセット上で Unity アプリを実行すると、Unity は深度バッファーを Windows に送信して、ピクセルごとの再プロジェクションを有効にします。通常、アプリによる明示的な作業を行わなくても、画質が向上します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-275">Note that when your Unity app runs on an immersive headset connected to a desktop PC, Unity will submit your depth buffer to Windows to enable per-pixel reprojection, which will usually provide even better image quality without explicit work by the app.</span></span> <span data-ttu-id="6f9c0-276">フォーカスポイントを指定すると、それによってピクセル単位の再プロジェクションがオーバーライドされるため、アプリが HoloLens で実行されている場合にのみ、この操作を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-276">If you provide a Focus Point, that will override the per-pixel reprojection, so you should only do so when your app is running on a HoloLens.</span></span>




```cs
// SetFocusPoint informs the system about a specific point in your scene to
// prioritize for image stabilization. The focus point is set independently
// for each holographic camera.
// You should set the focus point near the content that the user is looking at.
// In this example, we put the focus point at the center of the sample hologram,
// since that is the only hologram available for the user to focus on.
// You can also set the relative velocity and facing of that content; the sample
// hologram is at a fixed point so we only need to indicate its position.
renderingParameters.SetFocusPoint(
    currentCoordinateSystem,
    spinningCubeRenderer.Position
    );
```

<span data-ttu-id="6f9c0-277">フォーカスポイントの配置は、多くの場合、ホログラムが見ている内容によって異なります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-277">Placement of the focus point largely depends on what the hologram is looking at.</span></span> <span data-ttu-id="6f9c0-278">アプリには、参照用の宝石ベクトルがあり、アプリデザイナーはユーザーに対して確認するコンテンツを認識します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-278">The app has the gaze vector for reference and the app designer knows what content they want the user to observe.</span></span>

<span data-ttu-id="6f9c0-279">ホログラムを安定させるために開発者が実行できる最も重要な1つの点は、60 FPS でレンダリングすることです。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-279">The single most important thing a developer can do to stabilize holograms is to render at 60 FPS.</span></span> <span data-ttu-id="6f9c0-280">60 FPS を下回ると、安定化平面の最適化に関係なく、ホログラムの安定性が劇的に減少します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-280">Dropping below 60 FPS will dramatically reduce hologram stability, regardless of the stabilization plane optimization.</span></span>

<span data-ttu-id="6f9c0-281">**ベストプラクティス**安定化面を設定するための汎用的な方法はなく、アプリに固有のものであるため、主な推奨事項は、実際のシナリオに最適な動作を確認することです。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-281">**Best practices** There is no universal way to set up the stabilization plane and it is app-specific, so the main recommendation is to experiment and see what works best for your scenarios.</span></span> <span data-ttu-id="6f9c0-282">ただし、この平面上のすべてのコンテンツが完全に安定しているため、できるだけ多くのコンテンツを安定化平面に揃えるようにしてください。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-282">However, try to align the stabilization plane with as much content as possible because all the content on this plane is perfectly stabilized.</span></span>

<span data-ttu-id="6f9c0-283">例 :</span><span class="sxs-lookup"><span data-stu-id="6f9c0-283">For example:</span></span>
* <span data-ttu-id="6f9c0-284">平面コンテンツ (アプリの読み取り、ビデオ再生アプリ) のみがある場合は、安定化平面をコンテンツを持つ平面に揃えます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-284">If you have only planar content (reading app, video playback app), align the stabilization plane with the plane that has your content.</span></span>
* <span data-ttu-id="6f9c0-285">ワールドロックされた3つの小さな球体がある場合は、ユーザーのビューに現在存在するすべての球体の中心を "切り取り" にします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-285">If there are 3 small spheres that are world-locked, make the stabilization plane "cut" though the centers of all the spheres that are currently in the user's view.</span></span>
* <span data-ttu-id="6f9c0-286">シーンの深さが大きく異なる場合は、さらにオブジェクトを優先します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-286">If your scene has content at substantially different depths, favor further objects.</span></span>
* <span data-ttu-id="6f9c0-287">ユーザーが見ているホログラムと一致するように、すべてのフレームの安定化ポイントを調整してください。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-287">Make sure to adjust the stabilization point every frame to coincide with the hologram the user is looking at</span></span>

<span data-ttu-id="6f9c0-288">**回避すべき**こと安定化平面は安定したホログラムを実現するための優れたツールですが、誤用されると、イメージが不安定になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-288">**Things to Avoid** The stabilization plane is a great tool to achieve stable holograms, but if misused it can result in severe image instability.</span></span>
* <span data-ttu-id="6f9c0-289">ユーザーの背後にある安定化面を使用したり、ユーザーのビューに存在しなくなったオブジェクトにアタッチしたりすることができるため、"火災して忘れる" ことは避けてください。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-289">Don't "fire and forget", since you can end up with the stabilization plane behind the user or attached to an object that is no longer in the user's view.</span></span> <span data-ttu-id="6f9c0-290">安定化平面の法線が反対のカメラに設定されていることを確認します (例:-camera. forward)</span><span class="sxs-lookup"><span data-stu-id="6f9c0-290">Ensure the stabilization plane normal is set opposite camera-forward (e.g. -camera.forward)</span></span>
* <span data-ttu-id="6f9c0-291">安定した平面を極端に逆方向に変更しない</span><span class="sxs-lookup"><span data-stu-id="6f9c0-291">Don't rapidly change the stabilization plane back and forth between extremes</span></span>
* <span data-ttu-id="6f9c0-292">安定化平面を固定距離/向きに設定したままにしない</span><span class="sxs-lookup"><span data-stu-id="6f9c0-292">Don't leave the stabilization plane set to a fixed distance/orientation</span></span>
* <span data-ttu-id="6f9c0-293">安定化平面をユーザーに対して切り取ることを許可しない</span><span class="sxs-lookup"><span data-stu-id="6f9c0-293">Don't let the stabilization plane cut through the user</span></span>
* <span data-ttu-id="6f9c0-294">HoloLens ではなくデスクトップ PC で実行する場合は、フォーカスポイントを設定しないでください。代わりに、ピクセルごとの深度ベースの再プロジェクションに依存します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-294">Don't set the focus point when running on a desktop PC rather than a HoloLens, and instead rely on per-pixel depth-based reprojection.</span></span>

## <a name="color-separation"></a><span data-ttu-id="6f9c0-295">色の分離</span><span class="sxs-lookup"><span data-stu-id="6f9c0-295">Color separation</span></span> 

<span data-ttu-id="6f9c0-296">HoloLens ディスプレイの性質により、"カラー分離" と呼ばれるアーティファクトが認識されることがあります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-296">Due to the nature of HoloLens displays, an artifact called "color-separation" can sometimes be perceived.</span></span> <span data-ttu-id="6f9c0-297">これは、個々の基本色 (赤、緑、および青) に分割するイメージとしてマニフェストを持ちます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-297">It manifests as the image separating into individual base colors - red, green and blue.</span></span> <span data-ttu-id="6f9c0-298">このアイテムは、赤、緑、青が非常に多いため、白いオブジェクトを表示するときに特に表示できます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-298">The artifact can be especially visible when displaying white objects, since they have large amounts of red, green and blue.</span></span> <span data-ttu-id="6f9c0-299">これは、ユーザーが holographic フレーム間を移動しているホログラムを高速で視覚的に追跡するときに、最も顕著になります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-299">It is most pronounced when a user visually tracks a hologram that is moving across the holographic frame at high speed.</span></span> <span data-ttu-id="6f9c0-300">アーティファクトでマニフェストを実行するもう1つの方法は、オブジェクトのワープ/変形です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-300">Another way the artifact can manifest is warping/deformation of objects.</span></span> <span data-ttu-id="6f9c0-301">オブジェクトにハイコントラストやピュア色 (赤、緑、青) がある場合、色の分離は、オブジェクトのさまざまな部分のワープとして認識されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-301">If an object has high contrast and/or pure colors (red, green, blue), color-separation will be perceived as warping of different parts of the object.</span></span>

<span data-ttu-id="6f9c0-302">**ヘッドロックされた白いラウンドカーソルの色の分離の例は、ユーザーが頭を左右に回転させると、次のようになります。**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-302">**Example of what the color separation of a head-locked white round cursor could look like as a user rotates their head to the side:**</span></span>

![ヘッドロックされた白いラウンドカーソルの色の分離の例は、ユーザーが頭を左右に回転させた場合のようになります。](images/colorseparationofroundwhitecursor-300px.png)

<span data-ttu-id="6f9c0-304">色の分離を完全に回避することは困難ですが、それを軽減するために使用できる手法がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-304">Though it's difficult to completely avoid color separation, there are several techniques available to mitigate it.</span></span>

<span data-ttu-id="6f9c0-305">**色の分離は次のようになります。**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-305">**Color-separation can be seen on:**</span></span>
* <span data-ttu-id="6f9c0-306">[カーソル](cursors.md)などのヘッドロックオブジェクトを含む、すばやく移動するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-306">Objects that are moving quickly, including head-locked objects such as the [cursor](cursors.md).</span></span>
* <span data-ttu-id="6f9c0-307">[安定化平面](hologram-stability.md#reprojection)からかなり遠く離れたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-307">Objects that are substantially far from the [stabilization plane](hologram-stability.md#reprojection).</span></span>

<span data-ttu-id="6f9c0-308">**色の分離の効果を弱めるには、次のようにします。**</span><span class="sxs-lookup"><span data-stu-id="6f9c0-308">**To attenuate the effects of color-separation:**</span></span>
* <span data-ttu-id="6f9c0-309">オブジェクトをユーザーの宝石にラグさせる。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-309">Make the object lag the user's gaze.</span></span> <span data-ttu-id="6f9c0-310">これは、慣性があるかのように表示され、宝石の "スプリング" にアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-310">It should appear as if it has some inertia and is attached to the gaze "on springs".</span></span> <span data-ttu-id="6f9c0-311">これによりカーソルの速度が低下し (分離距離が短縮されます)、ユーザーの可能性のあるポイントの背後に配置されます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-311">This slows the cursor (reducing separation distance) and puts it behind the user's likely gaze point.</span></span> <span data-ttu-id="6f9c0-312">ユーザーが宝石の移動を止めたときにすぐに追いつくことができれば、自然な感じになります。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-312">So long as it quickly catches up when the user stops shifting their gaze it feels quite natural.</span></span>
* <span data-ttu-id="6f9c0-313">ホログラムを移動する場合は、ユーザーが目にすることが予想される場合は、移動速度を5°/秒未満にしてください。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-313">If you do want to move a hologram, try to keep its movement speed below 5 degrees/second if you anticipate that the user will follow it with their eyes.</span></span>
* <span data-ttu-id="6f9c0-314">カーソルには、 *geometry*ではなく*light*を使用します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-314">Use *light* instead of *geometry* for the cursor.</span></span> <span data-ttu-id="6f9c0-315">宝石に接続された仮想照明のソースは、対話型ポインターとして認識されますが、色の分離は行われません。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-315">A source of virtual illumination attached to the gaze will be perceived as an interactive pointer but will not cause color-separation.</span></span>
* <span data-ttu-id="6f9c0-316">ユーザーが行っているホログラムと一致するように安定化平面を調整します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-316">Adjust the stabilization plane to match the holograms the user is gazing at.</span></span>
* <span data-ttu-id="6f9c0-317">オブジェクトを赤、緑、または青にします。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-317">Make the object red, green or blue.</span></span>
* <span data-ttu-id="6f9c0-318">ぼやけたバージョンのコンテンツに切り替えます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-318">Switch to a blurred version of the content.</span></span> <span data-ttu-id="6f9c0-319">たとえば、丸い白のカーソルを、動きの方向に少しぼやけた線に変更することができます。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-319">For example, a round white cursor could be changed to a slightly blurred line oriented in the direction of motion.</span></span>

<span data-ttu-id="6f9c0-320">前と同様に、60 FPS でのレンダリングと安定化平面の設定は、ホログラムの安定性を確保するための最も重要な手法です。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-320">As before, rendering at 60 FPS and setting the stabilization plane are the most important techniques for hologram stability.</span></span> <span data-ttu-id="6f9c0-321">色の区別が目立つ場合は、まず、フレームレートが期待どおりであることを確認します。</span><span class="sxs-lookup"><span data-stu-id="6f9c0-321">If facing noticeable color separation, first make sure the frame rate meets expectations.</span></span>

## <a name="see-also"></a><span data-ttu-id="6f9c0-322">参照</span><span class="sxs-lookup"><span data-stu-id="6f9c0-322">See also</span></span>
* [<span data-ttu-id="6f9c0-323">Mixed Reality のパフォーマンスについて</span><span class="sxs-lookup"><span data-stu-id="6f9c0-323">Understanding Performance for Mixed Reality</span></span>](understanding-performance-for-mixed-reality.md)
* [<span data-ttu-id="6f9c0-324">色、ライト、マテリアル</span><span class="sxs-lookup"><span data-stu-id="6f9c0-324">Color, light and materials</span></span>](color,-light-and-materials.md)
* [<span data-ttu-id="6f9c0-325">本能的な操作</span><span class="sxs-lookup"><span data-stu-id="6f9c0-325">Instinctual interactions</span></span>](interaction-fundamentals.md)
* [<span data-ttu-id="6f9c0-326">MRTK ホログラム安定化</span><span class="sxs-lookup"><span data-stu-id="6f9c0-326">MRTK Hologram Stabilization</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/hologram-stabilization.html)
